## 浏览器输入url后发生了什么

![](.\static\browser_1.png)

##### 浏览器中的主要进程

- 浏览器主进程：负责控制浏览器标签页外的界面，包括地址栏、书签、前进后退按钮、以及和其他进程通信、存储功能
- GPU进程：负责整个浏览器界面的渲染
- 网络进程：负责发起和接收网络请求
- 渲染进程：将HTML、CSS、JS转为用户可以与之交互的网页（排版Blink引擎和V8引擎都是在该线程中）

#### 关键步骤

1. **处理输入信息：** 浏览器会对输入的url进行解析，分析所需要的传输协议和请求路径的地址。如果输入的url中的协议或者主机名不合法的，将会把地址栏中输入的内容传递给搜索引擎，搜索引擎会将其认定为关键字进行搜索。如果没有问题，会检查输入的url是否出现非法字符，如果出现非法字符则会对其进行转义后进行下一步
2. **判断是否有缓存 （强制缓存和协商缓存）**

3. **DNS解析获取IP地址:**  

   - 首先搜索浏览器的DNS缓存，缓存中维护着一张域名与IP地址的对应表
   - 未命中时，继续搜索操作系统的DNS缓存
   - 仍未命中时，操作系统将域名发送至本地域名服务器，本地域名服务器采用**递归查询**自己的DNS缓存
   - 仍未命中时，本地域名服务器向上级域名服务器进行**迭代查询**
     	1. 首先本地域名服务器向**根域名服务**器发送请求，根域名服务器返回顶级域名服务器的地址给本地域名服务器
      	2. 本地域名服务器向**顶级域名服务器**发送请求获取权限域名服务器的地址
      	3. 本地域名服务器向**权限域名服务器**发送请求获取该域名对应的IP地址

   - 本地域名服务器将得到的IP地址返回给操作系统，并自己将IP地址缓存起来
   - 操作系统将IP地址发送给服务器，操作系统将IP缓存起来
   - 浏览器得到域名和IP地址，浏览器将IP地址缓存起来

   ![](.\static\DNS_search.png)

4. **发送网络请求**

   - ：**TCP连接 ---- 三次握手**

     1. 第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段 （seq = x ）是一个任选的随机数，它代表的是客户端数据的初始序号，此时客户端处于 SYN_SEND 状态
     2. 第二次握手，服务端接收到syn包，服务器为连接分配tcp缓存和变量，然后向客户端发送TCP报文，其中:

     - 标志位为SYN和ACK（SYN=1,ACK = 1）表示确认客户端的seq序号有效，服务器可以正常接收客户端发送的数据，并同意创建连接
     - 序列号为seq  = Y （随机数）
     - 确定序号 ack = x + 1   表示收到客户端的序号Seq并将其加1设置为自己的确定序号ack,随后服务器进入 SYN-RCVD状态

     3. 客户端接收到服务端的确认收到数据的TCP报文后，明确从客户端到服务端的数据传输是正常的后，结束SYN-SEND状态，并返回报文：

        - 标志位为ACK（ACK = 1 ） 表示确定收到服务端的同意连接信号
        - 序列号为 seq = x +1 表示收到服务端的确定号 ACK 并将其作为自己的序号值
        - 确定序号为ack = y +1 表示收到服务端序列号 seq 并将其加1作为自己的确定好ack的值
        - 客户端进入ESTABLISHED阶段

        服务端收到客户端的确认收到服务端数据的报文后，明确服务器到客户端 的数据传输是正常的，结束SYN-RCVD状态，进入ESTABLISHED状态

   ![](.\static\tcp_connect.png)

   - **如果是https协议：** 会在tcp握手前建立TLS
     1. 第一步，客户端向服务器发送请求，请求中包括使用的协议版本号，生成的一个随机数，以及客户端支持的加密方法
     2. 第二步，服务器接收到请求后，确认双方使用的加密方法，并给出服务器的证书，以及一个服务器生成的随机数
     3. 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，然后发给服务器，并且还会提供一个前面所有内容的hash值，用来供服务器检验
     4. 第四步，服务器使用自己的私钥解密客户端发来的随机数，并提供前面所有内容的hash值来供客户端检验
     5. 第五步，客户端服务端根据约定的加密方法使用前面的三个随机数，生成对话密钥，以后的对话都是根据这个密钥来加密信息

5. **读取响应头信息：** 如果状态码是301，则会根据Location字段重定向到新地址 ，同时也会根据content-type决定如何进行响应。

6. **浏览器渲染页面：**

   [https://juejin.cn/post/6906814930092359693](https://juejin.cn/post/6906814930092359693)

   ![](.\static\rendertree.png)

   1. 解析HTMl构成DOM树
   2. 解析CSS生成CSSOM规则树
   3. 将DOM树和CSSOM规则树构建rendering  Tree
   4. 根据渲染树进行页面元素的布局
   5. 对渲染树进行分层操作，并生成分层树
   6. 将每个图层生成绘制列表，并提交到合成线程
   7. 合成线程将图层分成不同图块，并通过栅格化转化为位图
   8. 合成线程给浏览器进程发送绘制图块指令
   9. 浏览器进程生成页面

   **注意： **

   - 当解析文档时遇到外部js，并且没有设置async和defer，浏览器器会等待js加载完后并执行脚本，然后继续解析文档，对于设置的async defer的浏览器创建线程加载（异步加载），并继续解析文档，async脚本加载完后会立即执行
   - 遇到img标签时，先解析dom架构，然后浏览器异步加载src，并继续解析文档
   - css规则树会阻塞渲染，只有当css规则树构建完成后才会进入下一个阶段构建渲染树。通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。

7.  **TCP四次挥手**

   ![](.\static\tcp_disConnect.png)	

   1. 当客户端数据传输完成后，客户端向服务端发送连接释放报文，释放报文中包含 FIN标志位（FIN=1）、序列号seq = u   发送后客户端进入 FIN_WAIT_1 状态
   2. 第二次挥手，服务端接收到客户端释放请求后，服务端回复确认报文，报文包括ACK标志位（ACK= 1)，确定号ack  =  u + 1 ，序号 seq = v   服务端进入CLOSE_WAIT状态，此时的TCP处于版关闭状态，客户端到服务端的连续释放。客户端收到服务端的确定后，进入CLOSE_WAIT2 状态，等待服务端发出的连续释放报文
   3. 第三次挥手，服务端继续发送连续释放报文，报文包含FIN和ACK标志位（FIN = 1，ACK = 1）、确认号 ack = u+1 、 序号 seq = w ,服务端进入LAST_ACK（最后确认状态），等待客户端的确认
   4. 第四次挥手，客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。 

## 浏览器存储 

#### cookie 

cookie是服务端生成，客户端进行维护和存储的，存储再内存或者磁盘中

**应用方面：** 

- 会话状态管理
- 个性化设置
- 浏览器行为跟踪

**缺点：**

- 存储空间小，只有4kb，只能存储少量的数据
- 过多的cookie会造成巨大的性能浪费。cookie是和域名进行绑定的，同一个域名下的所有请求都会带上cookie，则会浪费很多的资源
- http中的请求是明文传输的，cookie可以被捕获到，会造成安全问题

#### session

session是保存在服务器的一种数据结构，是用户的唯一标识，用于跟踪用户状态。是基于cookie实现的

我们将一个用户一次对服务的访问称为会话，服务器在第一次接收到这个会话时，生成一个sessionID存储在服务器，然后通过http的set-cookie字段告诉浏览器把这个sessionID存储到浏览器，然后下次再发起请求的时候，将浏览器cookie中存储的sessionID通过cookie这个字段传给服务，服务可通过http请求带过来的sessionID在服务器中匹配是否有对应的sessionID，从而知道发起这个请求的用户是谁

![](.\static\session.png)

#### Token

访问资源接口时所需要的资源凭证

简单的token组成：

- uid： 用户唯一的身份凭证
- time：当前的时间戳
- sign ： 签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串）

**优点：**

- 服务端无状态化，可扩展性好

- 支持移动端设备

- 安全

![](.\static\token.png)

#### JWT : Json web Token

JWT 本质上就是一组字串，通过（`.`）切分成三个为 Base64 编码的部分：

- Header : 描述 JWT 的元数据，定义了生成签名的算法以及 `Token` 的类型。
- Payload : 用来存放实际需要传递的数据
- Signature（签名） ：服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。

**步骤：**

- 用户向服务器发送用户名、密码以及验证码用于登陆系统。

- 如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 `Token`。

- 用户以后每次向后端发请求都在 Header 中带上这个 `Token`。

- 服务端检查 `Token` 并从中获取用户相关信息。

**如何加强JWT安全性：**

- 使用安全系数高的加密算法。

- 使用成熟的开源库，没必要造轮子。

- Token 存放在 localStorage 中而不是 Cookie 中，避免 CSRF 风险。

- 一定不要将隐私信息存放在 Payload 当中。

- 密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。

- Payload 要加入 `exp` （JWT 的过期时间），永久有效的 JWT 不合理。并且，JWT 的过期时间不易过长。

### web Stroge

#### localstroge:

永久存储机制，存储空间大，除非通过js删除，否则数据永远不会过期

- 为localstorage设置过期时间 
- 惰性删除：可以在每一次get的时候判断是否过期，过期就删除，但是可能有一些永远也不会用到，就永远不会删除。所以也可以采用刷新就删除。
- 刷新删除：每次刷新进入页面就调用一次删除过期localstorage的函数

#### sessionstorage：

只存储会话信息，数据会保存到浏览器关闭，存在sesionsrorage中的数据不受页面刷新影响，可以在浏览器崩溃后重启恢复

#### indexdb：

用于**客户端存储大量结构化数据**，该api使用索引来实现对该数据的高性能搜索，IndexedDB 是一个运行在浏览器上的非关系型数据库理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储**二进制**数据。

- **采用键值对存储**
- 异步，防止大量数据读写，拖慢网页
- 支持事务：这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
- **受到同源限制**
- 存储空间大，理论上没有上限
- 支持二进制存储

## 浏览器安全

#### XSS ：跨站脚本攻击

攻击者通过注入非法的html标签或者js代码，使当前用户浏览改网页时，控制用户浏览器

代码注入攻击，攻击者在目标网站上诸如恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取cookie，session tokens，或者其他敏感的信息，对用户进行钓鱼欺诈

**本质：**恶意代码未经过过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意代码脚本被执行，有助于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击这定义的请求

**防御：**

- httponly：在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。
- 过滤：输入检查，HtmlEncode——标签转换。jsencode
- 对字符串进行转移编码

#### CSRF ：跨站请求伪造

攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。

#### 点击劫持：

利用透明按钮或链接做成陷阱，覆盖在web页面上，然后诱使用户在不知情的情况下，点击那个连接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing) 

两种方式：

- 攻击者使用一个透明iframe。覆盖在一个网页上，诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的 iframe 页面； 
- 攻击者使用一张图片覆盖在网页上，遮挡网页原有的位置含义

#### sql注入

让服务器执行攻击者期望的SQL语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。

思路：
将SQL语句放置于Form表单或请求参数之中提交到后端服务器，后端服务器如果未做输入安全校验，直接将变量取出进行数据库查询，则极易中招。

#### ddos攻击

分布式拒绝服务攻击
攻击者不断地提出服务请求，让合法用户的请求无法及时处理，就是dos攻击
攻击者使用多台计算机或者计算机集群进行dos攻击，就是ddos攻击

#### dns劫持

DNS域名解析系统
DNS提供服务用来将域名转换成IP地址

## 同源策略

同源策略是**若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制**，所谓的同源是指：协议、域名、端口号均要相同。

以下三个标签不受同源策略影响：

```
<img src = ''/>
<link href = ''/>
<script src = ''> </ script>
```

### 跨域：

指的是浏览器不能执行其他网站的脚本

### 解决跨域问题：

#### 一、JSONP 

利用script标签不受同源策略约束的特点，使得网页获取到动态产生的数据

网页创建一个script标签，将请求放入script标签的src属性下，使用回调函数来处理获取的数据

```js
    <script> 
           function show(params) {
                console.log(params);
            }

     </script>    
    <script src="https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=a&cb=show"></script>


```

**优缺点：**

1. JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。
2. 只能发送get请求，不安全，容易收到xss攻击

#### 二、CROS

服务端设置**Access-Control-Allow-Origin** 就可以开启 CORS。盖属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源

##### 1. 简单请求

- 使用 head / get / post 请求的
- Content-type 为 text/plain 或 multipart / form-data 或 application/x-www-form-urlencoded

##### 2.复杂请求

 复杂请求在正式通信前，增加一次option 预请求 ，通过该请求来指导服务端是否允许跨域请求

- 使用 put / delete 
- 发送json类型的数据
- 请求中有自定义的头部

#### 三、document.domain + iframe跨域

此方案仅限主域相同，子域不同的跨域应用场景(网页一级域名相同，只是二级域名不同)。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

#### 四、window.name + iframe跨域

浏览器窗口有`window.name`属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。并且可以支持非常长的 name 值（2MB）。

#### 五、postmessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，允许来自不同源得脚本采用异步方式进行有限的通信，可以实现跨文档，多窗口，跨域消息传递。它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

otherWindow.postMessage(message, targetOrigin, [transfer]);

#### 六、Node配置中间件

#### 七、Nginx反向代理

设置nginx的配置文件，实现反向代理

```js
server {
    listen       80;           //监听的端口
	server_name  localhost;
	location / {
            root   /Users/abc/dist/;       //入口文件
            index  index.html index.htm;
        }
 
        location /api/ {                 
                proxy_pass  https://xxx.xxx.xxx/req/;         //代理的地址
        }
}
```

#### 八、Vue开发阶段使用代理服务

配置vue的 vue.config.js配置文件

```js
module.exports = {
    entry: {},
    module: {},
    ...
    devServer: {
        historyApiFallback: true,
        proxy: [{
            context: '/login',
            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口
            changeOrigin: true,
            secure: false,  // 当代理某些https服务报错时用
            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
        }],
        noInfo: true
    }
}

```

