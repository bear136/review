[TOC]

# 手撕

## 排序

二分查找

```js
function search(arr,target){
    let len = arr.length -1;
    let low = 0;
    let high = len -1;
    while(low<=high){
        let mid = Math.floor((low+high)/2);
        let index = arr[mid];
        if(index>target){
            high = mid-1;
        }else if(index<target){
            low = mid+1
        }else{
            return mid;
        }
    }
    return -1;
}
```

冒泡排序

```js
function bubble(arr){
    let len = arr.length;
    for(let i = 0;i<len;i++){
        for(let j = 0;j<len-i-1;j++){
            if(arr[j]<arr[j-1]){
                const temp = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = temp;
            }
        }
    }
}
```

快速排序

```js
function quick(arr){
    if(arr.length<=1) return arr;
    let left = [],right = [];
    let pivotIndex = Math.floor(arr.length/2);
    let pivot = arr.splice(pivotIndex,1)[0];
    for(let i = 0;i<len;i++){
        if (arr[i] < pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
    }
    return quick(left).concat([pivot],quick(right));
}	
```

插入排序

```js
// 从第二个数往前比
// 比他大就往后排
// 以此类推，进行到最后一个数
function insert(arr){
    for(let i = 0;i<arr.length;i++){
        const temp = arr[i];
        let j = i;
        while(j>0){
            if(arr[j-1]>temp){
                arr[j] = arr[j-1];
            }else{
                break;
            }
            j -=1;
        }
        arr[j] = temp;
    }
}
```

选择排序

```js
// 找到数组中最小值，选中并将其放在第一位
// 然后找第二小的值放在第二位
// 以此类推，执行n - 1轮
function check(arr){
    for(let i = 0;i<arr.length;i++){
        let indexMin = i;
        for(let j = i;j<arr.length;j++){
            if(arr[j]<arr[indexMin]){
                indexMin = j;
            }
        }
        if(indexMin !== i){
            const temp = arr[i];
            arr[i] = arr[indexMin];
            arr[indexMin] = temp;
        }
    }
    return arr;
}
```

## 二叉树

先序遍历

```js
function front(arr){
    const res = [];
    const rec = (n)=>{
        if(!n) return;
        res.push(n.val);
        rec(n.left);
        rec(n.right);
    }
    rec(root);
    return res;
}
```

中序遍历

```js
function middle(arr){
    const res = []
    const rec = (n)=>{
        if(!n) return;
        rec(n.left);
        res.push(n);
        rec(right);
    }
    rec(root);
    return res;
}
```

后序遍历

```js
function middle(arr){
    const res = []
    const rec = (n)=>{
        if(!n) return;
        rec(n.left);
        rec(right);
        res.push(n);
    }
    rec(root);
    return res;
}
```

## promise

```js
class Promise{
    constructor(executor){
        this.state = 'pending';
        this.value = undefined;
        this.reason = undefined;
        let resolve = value =>{
            if(this.state === 'pending'){
                this.state = 'fulfilled';
                this.value = value;
            }
    	}
        let reject = reason = >{
            if(this.state === 'pending'){
                this.state = 'rejected';
                this.reason = reason;
            }
        }
    }
    try{
        executor(resolve,reject);
    }catch(err){
        reject(err);
    }	
	then(onFulfiled,onRejected){
        if(this.state === 'fulfilled'){
            onFulfilled(this.value);
        }
        if(this.state === 'rejected'){
            onRejected(this.reason);
        }
        return this;
    }
}
//promise.all
Promise.all = function(iterators){
    let promises = Array.from(iterators);
    let len = promises.length;
    let res = new Array(len);
    let resolveNum = 0;
    return new Promise((resolve,reject)=>{
        promises.forEach((promise,index)=>{
            Promise.resolve(promise)
            .then(value=>{
                res[index] = value;
                if(++resolveNum === len){
                    resolve(res);
                }
            })
            .catch(reject);
        })
    })
}
//promise.race
Promise.race = function(iterators){
    const promises = Array.from(iterators);
    return new promise((resolve,reject)=>{
        promises.forEach(promise=>{
            Promise.resolve(promise).then(resolve).catch(reject);
        })
    })
}
//promise.any
Promise.any = function(iterators){
    const promises = Array.from(iterators);
    let len = promises.length;
    let rejectedList = new Array(len);
    let rejectedNum = 0;
    return new Promise((resolve,reject)=>{
        promises.forEach((promise,index)=>{
            Promise.resolve(promise)
            .then(resolve)
            .catch(reason=>{
                rejectedList[index] = reason;
                if(++rejectedNum === len){
                    reject(rejectedList);
                }
            })
        })
    })
}
//promise.allsettled
const result = (success,value)=>{
    success
    ?{status:'fulfilled',value}
    :{status:'rejected',reason:value}
}
Promise.allSettled = function (iterators){
    const promises = Array.from(iterators);
    const len = promises.length;
    const settledList = new Array(len);
    let settledNum = 0;
    return new promise((resolve,reject)=>{
        promises.forEach((promise,index)=>{
            Promise.resolve(promise)
            .then(value=>{
                settledList[index] = result(true,value);
                if(++settledNum === len){
                    resolve(settledList);
                }
            })
            .catch(reason=>{
                settledList[index] = reason;
                if(++settledNum === len){
                    reject(settledList);
                }
            })
        })
    })
}
```

## 深浅拷贝

浅拷贝

```js
function clone(origin,target){
    let target = target || {};
    for(let prop in origin){
        target[prop] = origin[prop]
    }
    return target;
}
```

深拷贝https://juejin.cn/post/6889327058158092302#heading-6

```js

function deepClone(origin, target) {
  var target = target || {},
    toStr = Object.prototype.toString,
    arrStr = "[Object Array]";
  for (let prop in origin) {
    if (origin.hasOwnProperty(prop)) {
      if (origin[prop] !==null && typeof (origin[prop]) == "object") {
        if (toStr.call(origin[prop]) == arrStr) {
          target[prop] = [];
        } else {
          target[prop] = {};
        }
        deepClone(origin[prop], target[prop]);
      } else {
        target[prop] = origin[prop];
      }
    }
  }
  return target;
}



function deepClone(target,cache = new Map()){
  if(cache.get(target)){
      return cache.get(target)
  }
  if(target instanceof Object){
      let dist ;
      if(target instanceof Array){
        // 拷贝数组
        dist = [];
      }else if(target instanceof Function){
        // 拷贝函数
        dist = function () {
          return target.call(this, ...arguments);
        };
      }else if(target instanceof RegExp){
        // 拷贝正则表达式
       dist = new RegExp(target.source,target.flags);
      }else if(target instanceof Date){
          dist = new Date(target);
      }else{
        // 拷贝普通对象
        dist = {};
      }
      // 将属性和拷贝后的值作为一个map
      cache.set(target, dist);
      for(let key in target){
          // 过滤掉原型身上的属性
        if (target.hasOwnProperty(key)) {
            dist[key] = deepClone(target[key], cache);
        }
      }
      return dist;
  }else{
      return target;
  }
}

```

```js

// 数组去重
// 遍历
Array.prototype.unique = function () {
  let temp = {},
    arr = [],
    len = this.length;
  for (let i = 0; i < len; i++){
    if (!temp[this[i]]) {
      temp[this[i]] = "abc";
      arr.push(this[i])
    }
  }
  return arr;
}
// indexof——返回某个指定的字符串值在字符串中首次出现的位置
function unique(arr) {
  if (!Array.isArray(array)) {
    console.log('type error');
    return;
  }
  let res = [];
  let len = this.length;
  for (let i = 0; i < len; i++){
    let cur = array[i];
    if (res.indexOf(cur) === -1) {
      res.push(cur);
    }
  }
  return res;
}
//利用sort先将数组进行排序，然后判断当前元素与前一个元素是否相同，相同说明重复，不相同就添加进res
function unique(arr) {
  arr = arr.sort();
  let res = [arr[0]];
  for (let i = 0; i < len; i++){
    if (arr[i] !== arr[i - 1]) {
      res.push(arr[i]);
    }
  }
  return res;
}
// 利用splice
function unique(arr) {
  let len = arr.length;
  for (let i = 0; i < len; i++){
    for (let j = i + 1; j < len; j++){
      if (arr[i] == arr[j]) {
        arr.splice(j, 1);
        j--;
      }
    }
    return arr;
  }
}
// .filter——创建一个新数组，新数组元素是通过检查数组中符合条件的所有元素，filter不会对空数组进行检测，也不会改变原数组
function unique(arr) {
  return arr.filter(function (item, index, arr) {
    return arr.indexOf(item, 0) === index;
  })
}
// 利用set
function unique(arr) {
  return Array.from(new Set(arr));
}
// map——返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值；按照原始数组元素顺序依次处理元素
function unique(arr) {
  const seen = new Map();
  return arr.filter((a) => !seen.has(a) && seen.set(a, 1));
}



// 数组拍平

// 使用reduce
let flat = (arr) => {
  return arr.reduce((pre, cur) => {
    return pre.concat(Array.isArray(cur)?flat(cur):cur)
  },[])
}

// 递归
const res = [];
const fn = arr => {
  for (let i = 0; i < arr.length; i++){
    if (Array.isArray(arr[i])) {
      fn(arr[i])
    } else {
      res.push(arr[i])
    }
  }
}


// 手写promise
// 类的实现
class Promise{
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    // 成功
    let resolve = value => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
      }
    };
    // 失败
    let reject = reason => {
      if (this.state === "pending") {
        this.state = 'rejected';
        this.reason = reason;
      }
    };
    // 立即执行
    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }
  then(onFulfilled, onRejected) {
    if (this.state === 'fulfilled') {
      onFulfilled(this.value);
    }
    if (this.state === 'rejected') {
      onRejected(this.reason);
    }
    return this;
  }
}
// promise.all
// 只有参数实例的状态都变成fulfilled，p的抓鬼太才会变成fulfilled，此时参数promise的返回值组成一个数组，传递给promise的回调函数
// 只要实例promise之中有一个被rejected，p的状态就变成rejected，此时第一个被rejected的实例的返回值，会传递给promise的回调函数
Promise.myAll = function (iterators) {
  const promises = Array.from(iterators);
  const num = promises.length;
  const resolvedList = new Array(num);
  let resolvedNum = 0;
  return new Promise((resolve, reject) => {
    promises.forEach((promise,index)=> {
      Promise.resolve(promise)
        .then(value => {
          resolvedList[index] = value;
          if (++resolvedNum === num) {
            resolve(resolvedList);
          }
        })
        .catch(reject);
    })
  })
}
// promise.race:只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
Promise.myRace = function (iterators) {
  const promises = Array.from(iterators);
  return new Promise((resolve, reject) => {
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(resolve)
        .catch(reject);
    })
  })
}

// promise.any:只要有一个变为fulfilled包装实例就会变成fulfilled状态；如果所有实例都变成rejected状态就会变成rejected状态
Promise.myAny = function (iterators) {
  let promises = Array.from(iterators);
  let len = promise.length;
  let rejectedList = new Array(len);
  let rejectedNum = 0;
  return new Promise((resolve, reject) => {
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          resolve(value)
        })
        .catch(error => {
          rejectedList[index] = error;
          if (++rejectedNum === len) {
            reject(rejectedList);
          }
      })
    })
  })
}
// promise.allSettled.希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。此返回的 promise 实例的状态只能是fulfilled。
const result = (success, value) => {
  success
    ? { status: 'fulfilled', value }
    : { status: 'rejected', reason: value };
}
Promise.MyAllSettled = function (iterators) {
  const promises = Array.from(iterators);
  const len = promises.length;
  const settledList = new Array(len);
  let settledNum = 0;
  return new Promise((resolve, reject) =>{
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((value) => {
          settledList[index] = result(true, value);
          if (++settledNum === len) {
            resolve(settledList);
          }
        })
        .catch((error) => {
          settledList[index] = result(false, error);
          if (++settledNum === len) {
            reject(settledList);
          }
      })
    })
  })
}

// sleep的实现——延迟执行，核心使用settimeout方法
// 直接使用settimeout
let sleepFun = function (fun, time) {
  setTimeout(() => {
    fun()
  }, time);
}
let fun = () => console.timeEnd('time');
console.time("time");
sleepFun(fun, 1000);
// promise实现
let sleepFun = (time) => new Promise((resolve) => setTimeout(resolve, time));
let fun = () => console.timeEnd('time');
console.time("time");
sleepFun(3000).then(fun);
// generator
let fun = () => console.timeEnd('time');
function* sleepFun(time) {
  yield new Promise((resolve) => {
    setTimeout(resolve, time);
  })
}
console.time('time');
sleepFun(1000).next().value.then(fun);
// async await
async function wait(time) {
  console.time('time');
  await sleepFun(time);
  fun();
}
wait(3000);

// forEach——对每一项都执行，但没有返回值.三参：数组元素，元素索引，数组本身
Array.prototype.myForeach = function (f,obj) {
  let len = this.length;
  let _this = arguments[1] || window;
  for (let i = 0; i < len; i++){
    func.call(_this, this[i], i, this);
  }
}
// filter——函数返回true的项会自动组成数组后返回。三参：数组元素，元素索引，数组本身
Array.prototype.myFilter = function (func, obj) {
  let len = this.length;
  let arr = []
  let _this = arguments[1] || window;
  for (let i = 0; i < len; i++){
    func.call(_this, this[i], i, this) && arr.push(this[i]);
  }
  return arr;
}
// map——返回由每次函数调用的结果构成的数组。三参：数组元素，元素索引，数组本身
Array.prototype.myMap = function (func, obj) {
  let len = this.length;
  let arr = [];
  let _this = arguments[1] || window;
  for (var i = 0; i < len; i++) {
    arr.push(func.call(_this, this[i], i, this));
  }
}
// reduce——迭代数组所有项，四个参数：上一个归并值，当前项，当前项索引，数组本身
Array.prototype.myReduce = function (fn, initialValue) {
  let len = this.length,nextValue,i;
  if (!initialValue) {
    // 没有传第二个参数
    nextValue = this[0];
    i = 1;
  } else {
    // 传了第二个参数
    nextValue = initialValue;
    i = 0;
  }
  while (i < len) {
    nextValue = func(nextValue, this[i], i, this);
  }
  return nextValue;
}
// 实现call
Function.prototype.myCall = function (context) {
  let ctx = context || window;
  // 新增 fn 属性,将值设置为需要调用的函数
  ctx.fn = this;
  const args = Array.from(arguments).slice(1);
  let result = ctx.fn(...args);
  delete ctx.fn;
  return result;
}
// 实现apply
Function.prototype.myApply = function (context,arr) {
  let ctx = context || window;
  // 新增 fn 属性,将值设置为需要调用的函数
  ctx.fn = this;
  let result;
  if (!arr) {
    result = ctx.fn();
  } else {
    result = ctx.fn(...arr);
  }
  delete ctx.fn;
  return result;
}
// 实现bind
Function.prototype.myBind = function(context,...args){
  if (typeof this !== 'function') return;
  // 用来接收是谁调用的bind
  let self = this;
  let fnNop = function () { };//定义一个空函数
  let fnBound = function (...args2) {
    // 检测new，如果instanceof结果为true则证明是new出来的实例，如果为false即为普通调用
    let myThis = this instanceof self ? this : context;
    return self.apply(myThis, args.concat(args2));
  }
  fnNop.prototype = this.prototype;
  fnBound.prototype = new fnNop();
  return fnBound;
}
// 函数柯里化
function createCurry(fn) {
  if(typeof fn !== "function"){
      throw TypeError("fn is not function.");
  }
  //复用第一个参数
  var args = [].slice.call(arguments, 1);
  //返回新函数
  return function(){	
      //收集剩余参数
      var _args = [].slice.call(arguments);
      //返回结果
      return fn.apply(this, args.concat(_args));
  }
}
// 手写偏函数
var _ = {};

function partial(fn) {
  var args = [].slice.call(arguments, 1);
  return function() {
    var position = 0, len = args.length;
    for(var i = 0; i < len; i++) {
      args[i] = args[i] === _ ? arguments[position++] : args[i]
    }
    while(position < arguments.length) args.push(arguments[position++]);
    return fn.apply(this, args);
  };
};

// 手写instanceof
let myInstanceof = (target, origin) => {
  while (target) {
    if (target.__proto__ === origin.prototype) {
      return true
    }
    target = target.__proto__;
  }
  return false;
}


// 手写jsonp
const jsonp = ({ url, params, callbackName }) => {
  const generateUrl = () => {
    let dataSrc = '';
    for (let key in params) {
      if (params.hasOwnProperty(key)) {
        dataSrc += `${key}=${params[key]}&`
      }
    }
    dataSrc += `callback=${callbackName}`
    return `${url}?${dataSrc}`;
  }
  return new Promise((resolve, reject) => {
    const scriptEle = document.createElement('script');
    scriptEle.src = generateUrl();
    document.body.appendChild(scriptEle);
    window[callbackName] = data => {
      resolve(data);
      document.removeChild(scriptEle)
    }
  })
}

// promise封装ajax
const getJson = function (url) {
  return new promise((resolve, reject) => {
    const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHttp');
    xhr.open('get', url, false);
    xhr.setRequestHeader('Accept', 'application/json');
    xhr.onreadystatechange = function () {
      if (xhr.readyState !== 4) return;
      if (xhr.status === 200 || xhr.status === 304) {
        resolve(xhr.responseText);
      } else {
        reject(new Error(xhr.responseText));
      }
    }
    xhr.send();
  })
}
// 手写promise.prototype.finally()
Promise.prototype.finally = function (callback) {
  let p = this.constructor;
  return this.then(
    value => Promise.resolve(callback()).then(() => value),
    error => Promise.resolve(callback()).then(() =>{ throw error})
  )
}

// vue2响应式原理
class Observer{
  // 观测值
  constructor(value) {
    this.walk(value);
  }
  walk(data) {
    // 对象上的所有属性依次进行观察
    let keys = Object.keys(data);
    for (let i = 0; i < keys; i++){
      let key = key[i];
      let value = data[key];
      defineReactive(data, key, value);
    }
  }
}
function defineReactive(data, key, value) {
  Observer(value);//递归
  // 如果value还是一个对象则继续走一边object.defineProperty层层遍历到value不是对象
  // 如果vue嵌套层级过深，性能会受影响
  Object.defineProperty(data, key, {
    get() {
      console.log("获取值");
      // 需要做依赖派发收集过程,代码未体现
      return value;
    },
    set() {
      if (newValue === value) return;
      console.log("设置值");
      // 需要做依赖派发更新过程,代码未体现
      value = newValue;
    }
  })
}
export function observe(value) {
  // 如果传过来的是数组或者对象，进行数据劫持
  if (
    Object.prototype.toString.call(value) === "[object Object]" || Array.isArray(value)
  ) {
    return new Observer(value);
  }
}

// vue如何检测数组变化
// 保留数组原型
const arrayProto = Array.prototype;
// 将arrayMethods继承自数组原型，面向切片思想(AOP)——不破坏封装，动态扩展功能
export const arrayMethods = Object.create(arrayProto)
let methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "reverse",
  "sort"
];
methodsToPatch.forEach((method) => {
  arrayMethods[method] = function (...args) {
    // 保留原型方法的执行结果
    const result = arrayProto[method].apply(this, args);
    // this代表的是数据本身，比如数据是{a:[1,2,3]},那么我们使用a.push(4) this就是a ob就是a.__ob__
    const ob = this.__ob__;
    // 这里的标志就是代表数组有新增操作
    let inserted;
    switch (method) {
      case "push":
      case "unshift":
        insert = args;
        break;
      case "splice":
        inserted = args.slice(2);
      default:
        break;
    }
    // 如果有新增的元素 inserted是一个数组 调用Observer实例的observeArray对数组每一项进行观测
    if (inserted) ob.observeArray(inserted);
    // 之后还可以在这里检测到数组改变了之后从而触发属兔更新的操作
    return result;
  }
})

//判断两个vnode的标签和key是否相同，如果相同，就可以认为是同意节点就地复用 
function isSameNode(oldVnode, newVnode) {
  return oldVnode.tag === newVnode.tag && oldVnode.key === newVnode.key;
}
// 根据key来创建index的映射表
function makeIndexByKey(children) {
  let map = {};
  children.forEach((item, index) => {
    map[item.key] = index;
  })
  return map;
}
let map = makeIndexByKey(oldCh);

// 先序遍历
// 递归
var preTraversal = function (root) {
  const res = [];
  const rec = (n) => {
    if (!n) return;
    rec.push(n.val);
    rec(n.left);
    rec(n.right);
  }
  rec(root);
  return res;
}
// 迭代
// 入栈 右=》左
// 出栈 中=》左=》右
var preTraversal = function (root, res = []) {
  if (!root) return;
  const stack = [root];
  let cur = null;
  while (stack.length) {
    cur = stack.pop();
    res.push(cur.val);
    cur.right && stack.push(cur.right);
    cur.left && stack.push(cur.left);
  }
  return res;
}
// 中序遍历
var midTraversal = function (root) {
  const res = [];
  const rec = (n) => {
    if (!n) return;
    rec(n.left);
    res.push(n.val);
    rec(n.right);
  }
  rec(root);
  return res;
}
// 入栈 左 -> 右
// 出栈 左 -> 中 -> 右
var midTraversal = function (root, res = []) {
  if (!root) return;
  const stack = [root];
  let cur = root;
  while (stack.length || cur) {
    if (cur) {
      stack.push(cur);
      // 左
      cur = cur.left;
    } else {
      //弹出 中
      cur = stack.pop();
      res.push(cur.val);
      // 右
      cur = cur.right;
    }
  }
  return res;
}
// 后序遍历
var backTraversal = function (root) {
  const res = [];
  const rec = (n) => {
    if (!n) return;
    rec(n.left);
    rec(n.right);
    res.push(n.val);
  }
  rec(root);
  return res;
}
// 入栈 左 -> 右
// 出栈 中 -> 右 -> 左 结果翻转
var postorderTraversal = function(root, res = []) {
  if (!root) return res;
  const stack = [root];
  let cur = null;
  do {
      cur = stack.pop();
      res.push(cur.val);
      cur.left && stack.push(cur.left);
      cur.right && stack.push(cur.right);
  } while(stack.length);
  return res.reverse();
};

// 原型链继承
function Parent() {
  this.name = 'tyx';
}
Parent.prototype.sayName = function () {
  console.log('1');
}
function Child() { }
Child.prototype = new Parent();
let child1 = new Child();
```

# 面试

面试官您好，我是来自西安邮电大学网络空间安全学院的田昀鑫，现在是大三，我从大二开始加入实验室系统学习前端，先后学习html，css，js，h5，c3，vue等，也对react，微信小程序，webpack有初步的了解，在学习过程中通过不断地实践来进行巩固，完成驾考系统，实验室官网等项目。

 ## 驾考宝典

驾考系统之后主要分为管理系统和用户端两部分

管理系统主要实现的功能就是题目，驾校的增删改查，图片上传还有查询；

用户端的话主要就是顺序答题和模拟答题功能的实现

### 登录

用户进入页面，再created函数中判断本地是否存储了账号以及密码，如果有的话回显在输入框，用户输入账号密码，点击登录，此时判断当前用户是否勾选记住密码框，如果选择了记住密码的话，则在本地存储信息。发送登陆请求时，我会对响应数据及进行拦截，获取后端生成的当前用户的token，然后对之后的每一次请求设置Authorization:’Bearer’+token，这样的话对之后进入系统的每一次请求就有权限了

### 记住密码：

在登陆表单中添加记住密码勾选框，methods中定义方法，判断用户是否勾选记住密码框，如果点击，则在本地存储中存储登录信息，再登陆中调用该函数，created函数中判断本地是否存储了账号以及密码，如果有的话回显在输入框

### 图片上传

我是用element-ui组件库中的upload实现的这个题目上传，由于我们上传题目的话是需要携带token的，由于我们在登录的时候就已经将这个token进行了本地保存，所以在upload组件中设置请求头：headers时，向本地存储中获取token，然后进行携带

### 图片懒加载：

在登录管理系统时，会获取到所有的题目，由于管理员登陆之后是不可能一次性看到所有题目的，如果一次性获取所有图片资源的话时间过长，会影响用户体验，我们设置图片懒加载之后会减少无效资源的加载，防止并发加载的资源过多会阻塞js的加载

实现：

**引入了intersectionapi，（构造函数）观察元素是否可见，因为我每页只显示五张图片，所以我预设的是一次性加载****10****张图片，因为每道题都有自己的题号，所以利用intersectionobserver** **api每隔1****0****个题号做监听，判断该部分1****0****道题是否进入可视区域。通过判断每个被监听元素的isIntersecting属性来判断是否进入到可视区域，进入到可视区域就将data****-****src属性赋值给src**

![img](file:///C:\Users\田甜圈\AppData\Local\Temp\ksohtml\wps4452.tmp.jpg) ![img](file:///C:\Users\田甜圈\AppData\Local\Temp\ksohtml\wps4453.tmp.jpg)

将页面上的图片的src属性设置为空字符串，而图片的真实路径设置在data-original属性中，当页面滚动的时候监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区域内，则将图片的src属性值设置为data-original的值。我们需要知道窗口显示区的高度innerHeight，然后是图片到视窗上边的距离getBoudingClientRect().top，但是这种方法的话，scroll事件密集发生，计算量比较大，性性能消耗比较多。

### 顺序答题，模拟答题

顺序答题获取所有题目：

当选择框选中时获取选中的值，点击确认的时候，判断其是否正确，正确的话显示为绿色，错误的话为红色，当点击上一题或者下一题的时候重置样式，调用vuex定义好的方法切换题目

模拟答题

也是选中的值，当点击确认的时候不再改变样式，直接变为下一题，如果正确，正确题目数加1，错误的话，错误的加1 ，点击交卷的时候将错误题目数传给后台，然后获取响应数据中的分数并显示，并将本次答题时间以及成绩记录下来，可以再考试记录中查看。

## 微光——零信任赋能远程安全办公系统	

### 微信小程序登录

*all*当两个api都成功之后再将iv，encryptedData，code以及账号以及密码发送给后端进行验证，验证成功之后返回动态凭证

——调用接口获取动态凭证，通过凭证进而获取用户登陆态信息。包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。

Wx.getuserprofile:获取用户信息，页面产生***\*点击事件后\****才可以调用，每次请求都会弹出授权弹窗口，用户同意后返回userinfo

***\*路由控制&动态渲染\****

用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页；如果跳过登陆页面手动输入业务页面的话直接强制转为登陆页面。后端在判断完用户相关信息之后，根据用户的权限会给我返回当前用户所能访问的功能信息以及路由，将信息保存在vuex里，根据保存vue中的信息，动态渲染出其权限内以及权限外的功能，当用户需要跳转页面时，先调用vuex中的方法判断当前要跳转的路由是否在权限范围内，如果在就进行路由跳转，如果没有的话就返回到登陆页面。

### ***\*实验室官网完善\****

实验室官网中含有很多我们实验室的照片以及信息，所以每隔一定的时间需要更改，然后当时学长写这个的时候没有考虑到在之后更换的问题，所以就由我写了一个用来更改图片以及文字信息的后台。主要用的也是elementui中的upload的组件。

***\*照片墙\****

原来是使用浮动实现的网格形式的照片墙，类似于windows中的磁贴，需要改为flex进行布局（使用float布局的时候需要为每一个元素设置浮动，而且元素之间间距以及对齐方式的话不用一个调节参数，直接使用justify-content就可以）flex-wrap：wrap设置换行，justify-content在添加的后台里面在照片前上传的时候需要点击照片然后再上传，点击的时候会用边框显示出我们选择的图片，但是这样的话添加的border会导致原本的布局位置发生改变，所以对每一个照片都设置成怪异盒模型，也就是设置了box-sizing为borderbox，这样的话就算点击之后增加边框，也会自动计算在宽高里，不会影响布局。

![img](file:///C:\Users\田甜圈\AppData\Local\Temp\ksohtml\wps4454.tmp.jpg) 

***\*轮播图优化\**

无缝轮播图，加过渡

# html文档根节点是什么？

Document。当浏览器载入html文档，就会成为document对象，document对象是html文档的根节点。我们可以根据document对象对html页面中所有元素进行访问，document对象是window对象的一部分。

# 简述html，css

html：hypertext markup language——超文本标记语言，一种标记语言，用来描述网页

css：  ——层叠样式表，描述了如何显示html元素

# <!Doctype>声明

https://www.w3school.com.cn/tags/tag_doctype.asp

doctype声明有助于在浏览器中正确显示网页，位于文档中最前面的位置，不是标签，用来告知web浏览器使用哪种版本的html。严格模式的排版和js运作模式是以该浏览器支持的最高标准运行。在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现

混杂模式

- 盒模型：混杂模式下是怪异盒模型
- 标准模式下，div中只有图片的时候，图片下会有3px的空白，混杂模式不会留有空白<img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211129103908033.png" alt="image-20211129103908033" style="zoom: 67%;" />
- 混杂模式下，字体不会继承父元素的字体
- 混杂模式下给内联元素设置宽高都是有效的
- 标准模式基于内容的百分比
  混杂模式下，如果父级元素设置行内，浮动，绝对定位，以父级的宽度为标准，如果父级没有宽度，往上一层找
- 标准模式下，如果元素超出框外，会自动裁剪
  混杂模式下，如果元素超出框外，元素会自动适应内容

### HTML 5

```
<!DOCTYPE html>
```

### HTML 4.01 Strict

该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

### HTML 4.01 Transitional

该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
"http://www.w3.org/TR/html4/loose.dtd">
```

### HTML 4.01 Frameset

该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。

```
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" 
"http://www.w3.org/TR/html4/frameset.dtd">
```

### XHTML 1.0 Strict

该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

### XHTML 1.0 Transitional

该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "
http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

### XHTML 1.0 Frameset

该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。

```
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

### XHTML 1.1

该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。

```
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
```

# 标签

- title：定义文档标题，lang属性，规定元素中内容的元素编码

- meta：html辕信息，字符集声明，视口声明等
  - content属性：定义与 http-equiv 或 name 属性相关的元信息。
  
  - charset属性：定义文档的字符编码

  - http-equiv属性：将content属性关联到http头部
  
    - content-type：规定文档的字符编码   
  
      <meta http-equiv="content-type" content="text/html; charset=UTF-8">
      </meta>
  
    - default-style：规定要使用的预定义的样式表
    - refresh：定义文档自动刷新的时间间隔
  
  - name属性：将content属性关联到一个属性
  
    
  
  利用meta标签实现定时刷新
  
  
  
- link：引入外部样式表

- base：定义文档基础url地址，在文档中所有的相对地址形式都以此为相对地址

- head：定义文档头部信息，引用脚本，只是浏览器找样式表，提供元信息

# h5新特性

https://juejin.cn/post/6917044041863397383

# html5新标签

![image-20211123154138851](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211123154138851.png)

# 字符编码

https://juejin.cn/post/6844903714151464974

<img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211116174546261.png" alt="image-20211116174546261" style="zoom:50%;" />

ascii：每个字母或符号占1byte，并且最高位为0，因此ascii能编码的字母和符号只有128个，标准的只有128个，现在大多使用的是扩展的

GB2312：最早一版的中文编码，**每个字占据2bytes**。由于要和ASCII兼容，那这2bytes最高位不可以为0了（否则和ASCII会有冲突）。在GB2312中收录了6763个汉字以及682个特殊符号，已经囊括了生活中最常用的所有汉字。

GBK：GBK中在保证不和GB2312、ASCII冲突（即兼容GB2312和ASCII）的前提下，也用每个字占据2bytes的方式又编码了许多汉字。经过GBK编码后，可以表示的汉字达到了20902个，另有984个汉语标点符号、部首等。值得注意的是这20902个汉字还包含了繁体字，但是该繁体字与台湾Big5编码不兼容，因为同一个繁体字很可能在GBK和Big5中数字编码是不一样的。

GB18030：GB18030多出来的汉字使用4bytes编码

UTF-8：UTF8解决字符间分隔的方式是数二进制中最高位连续1的个数来决定这个字是几字节编码。0开头的属于单字节，和ASCII码重合，做到了兼容。

# seo优化

搜索引擎优化，采用易于搜索引擎索引的合理手段，使网站各项基本要素适合搜索引擎检索原则，对用户更友好，更适合爬虫获取信息使得用户在访问网站时能排在前面。

- 控制首页链接数量
- 扁平化的目录层次，即目录尽量不超过三级
- 导航优化，图片代码必须添加alt和title
- 网站的结构布局
- 利用布局，将重要内容的html代码放在前面
- 控制页面大小，减少http请求，提高网站的加载速度

# 语义化

- 网页加载慢时，css未加载时页面清晰，可读好看
- 提升用户体验，title，alt
- 有利于seo
- 方便其他设备解析页面：例如屏幕阅读器，盲人阅读器，移动设备等
- 使代码具有可读性，便于团队开发以及维护

# web标准以及w3c

参考：https://juejin.cn/post/6844904017680662536

# svg和canvas

都可以在浏览器上绘制图形

- canvas是h5新提供的绘图方法，svg已经有了十多年的历史
- canvas绘图基于像素点，是位图，放大或者缩小会失真，于分辨率有关；svg基于图形，用html标签描绘形状，放大或缩小不会失真，与分辨率无关
- canvas需要在js中绘制，svg在html中绘制
- canvas支持的颜色比较多
- canvas不能为绘制对象绑定相关事件；再svg中可以为绘制对象绘制对象绑定相关事件

# src与href

- src用于替换当前元素，href用于在当前文档于应用资源之间确立联系

  <script src="js.is"></script>当浏览器解析道该元素时，会暂停其他资源的下载和处理，直至讲该资源加载，编译，执行完毕，图片和框架等元素也如此，类似于将所指资源嵌入当前标签内；

- href是Hypertext Reference的缩写，指向网络资源所在位置，如果我们在文档中添加<Link href="Commom.css" rel="Stylesheet"/>那么浏览器会识别该文档为css并行下载资源并且不会停止对当前文档的处理

# 伪类与伪元素

**伪类用于当已有元素处于的某个状态时，为其添加的样式；**

常见有:link,:visited,:hover,:active,:first-child,:nth-child。![image-20210819112538864](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210819112538864.png)

**伪元素用于创建一些不存在文档树的元素并为其添加样式；**

例如：::after，::before![image-20210819112544392](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210819112544392.png)

# css成为规范的几个阶段

- 编辑草案ED：初始阶段，非常粗糙
- 首个公开工作草案FPWD：受个公开版本，开始接受公所组反馈
- 工作草案WD：会吸收来自工作组以及社区的反馈，浏览器早期实现通常从这个阶段开始
- 候选推荐规范CR：相对稳定版本，比较适合实现和测试
- 提名推荐规范PR：w3c会员公司对着这项规范表达反对意见的最后机会
- 正式推荐规范REC：一项W3c技术规范的最终阶段

# 引入方式

- link
- style标签
- 行间样式
- @import引入
- js

行内样式>链接样式>导入样式

@import与link的区别：

- link是html标签，除了能导入css资源还能导入别的资源，图片，字体等，@import是css的语法，只能引入css的资源
- link导入的样式会在页面加载时同时加载，@import导入的样式需要等待页面加载完成后加载
- link没有兼容性问题，@import不支持IE5以下
- link可以通过js操作dom动态引入样式表改变样式，而@import不可以

# 浏览器中识别样式表的顺序

- 文件开头的Byte order mark字符值，不过一般编辑器闭关不能看到文件头里的bom值
- http响应头里的content-type字段包含的charset所指定的值
- css文件头里定义的@charset规则里值定的字符编码
- <link>标签里的charset属性，——html5中已经废除
- 默认是utf-8 

# 自定义属性实现变量

需要用--x的格式声明
<!-- 定义自定义属性 -->
:root {
  --theme-color: red;
}
<!-- 使用变量 -->
h1 {
  color: var(--theme-color);
}

# 行级元素，块级元素

区别：

- 行级元素允许多个排列，块级元素独占一行
- 块级元素可以设置width,height,行级元素设置无效
- 行级元素水平设置margin padding有效，竖直无效

行级元素：span，strong，em，a，br

块级元素：div，p，ul，ol，li，form，address，h

行级块元素：img,input

# bfc

块级格式化上下文，为页面中一个独立的小容器，是独立布局的，有自己的渲染规则，盒子里面的子元素的样式不会影响到外面的元素

触发方式：

- float属性不为none——left，right，inherit
- 根元素或包含根元素的元素
- overflow：hidden/auto 。不为visible
- position为**absolute或fixed**
- display：inline-block/table-cell/table-caption/table/inline-table/flow-root/flex/inline-flex/grid/inline-grid
- contain值为layout,content或strict。属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。

用途：

- 清除父元素内部子元素的浮动——子元素浮动脱离文档流，不能撑开父元素高度，此时设置父元素bfc，包裹子元素即可
- 解决外边距浮动问题。**margin collapsing——外边距叠加：**当相邻块元素的外边距结合为为单一的外边距时，就会取两者之间较大的值，出现于垂直方向。
- 两栏布局。前一个元素浮动，后一个元素触发bfc便可实现两栏布局

# z-index

z-index用来描述定义一个元素在屏幕z轴上的堆叠顺序。

z-index仅仅在定位元素上有效果

判断在z轴上的堆叠顺序，不仅仅是直接比较两个元素的z-index的带线啊哦，这个堆叠顺序实际是由元素的 层叠上下文，层叠等级共同决定的

# 层叠上下文

https://blog.csdn.net/llll789789/article/details/97562099

如何产生层叠上下文：

1. html中的根元素——根层叠上下文
2. 普通元素设置position属性为非static值并设置z-index为具体数值，产生层叠上下文
3. css新属性也可以产生层叠上下文
   1. 父元素的display属性值为`flex|inline-flex`，子元素`z-index`属性值不为`auto`的时候，子元素为层叠上下文元素；
   2. opacity不为1
   3. 元素的transform不为none
   4. 元素的`filter`属性值不是`none`；


层叠顺序：

- 形成层叠上下文的背景和边框
- 负z-index值
- 块级盒
- 浮动盒
- 行内盒
- z-index:0;
- 正z-index值

# 盒子模型

可以通过设置box-sizing来标识其时哪一种盒模型。content-box为标准盒模型，border-box为怪异盒模型（ie盒模型为怪异盒模型）

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\4415f873-337f-40b7-a538-d343897929c6.png?t=1627294373417)

标准盒模型——contentbox。width = content

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\a018ccf9-aeb0-47e4-8921-c023eeb7aa42.png?t=1627294373418)

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\ff246a63-5851-4b4b-8d86-1d33782d6365.png?t=1627294373418)

怪异盒模型——borderbox。width = content+padding+border

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\14ee29a5-5491-4245-8eb3-3de6180d170f.png?t=1627294373418)

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\3eb1d226-8b99-4ace-a7ee-598e7e4a6ef0.png?t=1627294373418)

# css选择器及权重

| !important        | infinity |
| ----------------- | -------- |
| 行间样式          | 1000     |
| id                | 100      |
| class\|属性\|伪类 | 10       |
| 标签\|伪元素      | 1        |
| *                 | 0        |

权重部分数字为256进制

属性选择器

- [[*attribute*\]]() 用于选取带有指定属性的元素。
-  [[*attribute*=*value*\]]() 用于选取带有指定属性和值的元素。
-  [[*attribute*~=*value*\]]() 用于选取属性值中包含指定词汇的元素。 
- [[*attribute*|=*value*\]]() 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。
- [[*attribute*^=*value*\]]() 匹配属性值以指定值开头的每个元素。
- [[*attribute*$=*value*\]]() 匹配属性值以指定值结尾的每个元素。
-  [[*attribute**=*value*\]]() 匹配属性值中包含指定值的每个元素。

\>直接子元素选择器  +直接相邻选择器——相邻的同级元素  ~普通相邻选择器——同级元素

# position方法有哪些

- absoluted：绝对定位，相对于非static定位的第一个父元素进行定位
- relative：相对定位，相对于其出生位置进行定位
- static：默认值， 没有定位
- fixed：相对于浏览器视口进行定位
- sticky：relative和fixed的结合体
  - 使用条件
    - 父元素不能使用overflow：hidden/auto
    - 必须指定top,left,bottom,right四个值之一即可，否则会处于相对定位
    - 父元素高度不能低于sticky元素高度
    - 仅在其父元素内生效
  - 注意
    - 不会触发bfc
    - z-index无效
    - 当父元素高度为100%时，页面滑动到一定高度sticky回失效
    - IE低版本不支持sticky的使用

# align-content，align-items与align-self的区别

align-content对于单行的盒子不起作用，可以通过flex-wrap属性使其生效align-items不区分单行或多行

# 水平垂直居中

水平居中

- 行内：text-align:center
- margin:0 auto;
- 绝对定位和margin-left：自身宽度的-1/2或者transform:translateX(-50%)
- position：absolute；上下左右设置为0，margin设置为auto
- display：flex；justify-content：center；
- ![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\3d86bbc7-8fd3-45f4-8bd7-cf3e04e2ebfa.png?t=1627294373450)

垂直居中

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\e4f94b75-8279-419e-86ef-eac55a97a60f.png?t=1627294373452)

**多行文本垂直居中**

# 如何用一个div实现textarea

textarea   标签定义多行文本的文本输入控件

```js
<div class="left" contenteditable="true"></div>
```

# float

1. float即为浮动，在css中的作用是使元素脱离正常的文档流并使其移动到其父元素的最左边或者最右边
2. 文档流：在html中文档流即为元素从上到下排列的顺序
3. 脱离文档流：元素从正常的排列顺序被抽离
4.  最左/右边：元素往左或往右移动直至碰到另一个浮动元素或父元素内容去的边界(不包括padding)

## float造成的影响

- 对**父元素**来说，元素浮动之后，脱离当前正常的文档流，所以无法撑开父元素，造成父元素塌陷
- 对**非浮动**的**兄弟元素**来说。如果兄弟元素为**块级元素**，在现代浏览器以及IE8+下，该元素会忽略浮动元素并占据它的位置，并且元素处于浮动元素下层(z-index无法改变他们的层叠位置)，但它的内部文字和其他行内元素都会环绕浮动元素。**在IE 6、7下则分别都有不同的表现，IE 6、7中，该兄弟元素会紧跟在浮动元素的右侧，并且在IE6中两者之间留有3px的空隙。这就是著名的“IE 3px bug”。**如果兄弟元素为**内联元素****，**则元素会环绕浮动元素排列

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\a8e98cc4-43df-44e1-be61-3be421fb1b5c.png?t=1627294373469)

- 对**浮动**的**兄弟元素**来说，如果是**同一方向**的浮动元素，会紧跟在后面；如果是**反方向**的浮动元素，在同一条直线上。

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\6957ffd3-2172-4ae7-8a9b-3e5efad76571.png?t=1627294373477)

- 对**自身元素**的影响：float对象被视作块对象，即display属性为block；
- 对**子元素**的影响：当一个元素浮动时，在没有清除浮动的情况下，无法撑开父元素，但是可以让自己的浮动子元素撑开自身，在没有定义具体宽度的情况下，是自身的宽度从100%变为自适应(浮动元素display:block).其高度宽度均为浮动元素高度合非浮动元素高度之间的最大值

优点：

1. 文本环绕图片——float最初的意义
2. 应用于网页布局

## 清除浮动

**当一个元素是浮动的，如果没有关闭浮动时，其父元素不会包含这个浮动元素，因为此时浮动元素从文档流脱离**

1. clear：both：使用这种方法需要增加一个额外元素，并且定义其样式为clear:both
2. overflow：在浮动元素上加入overflow:hidden/auto，auto对seo比较好;**overflow:visible**无法达到清除浮动的效果。
3. clearfix：利用:after和:before在元素内部插入两个元素 —— 伪类+clear:both![image-20211125103603502](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211125103603502.png)
4. **给父元素设置display:inline-block属性**

# flex布局

flex布局——弹性布局，用来为盒装模型提供最大的灵活性设置flex之后，子元素**的float,clear,vertical-align**属性将失效。容器默认存在两根轴，水平主轴盒垂直交叉轴，容易实现垂直居中

设置在父容器上的值：

- \1. flex-direction：row|column|row-reverse|column -reverse决定主轴方向
- \2. flex-wrap：nowrap|wrap|wrap-reverse决定如果一条轴线排不下如何换行
- \3. flex-flow:1和2的简写形式，默认值为row nowrap
- \4. justify-content：定义了项目再主轴上的对齐方式
  flex-start/end|center|space-between/around
- \5. align-items：定义在交叉轴上如何对齐
  flex-start/end|center||baseline|stretch——如果项目未设置高度或设为auto，将占满整个容器的高度
- \6. align-content：属性定义了多根轴线的对齐方式
  flex-start/end|center|space-between/around|stretch

# grid布局

**容器属性**

grid-template-columns:定义每一列的列宽
grid-template-rows：属性定义每一行的行高
grid-row-gap：设置行与行的间距
grid-column-gap：设置列与列的间距
grid-gap：为grid-row-gap与grid-column-gap的合并简写方式
grid-template-areas：定义区域
grid-auto-flow：row|column划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格，默认的放置顺序是先行后列
justify-items：设置单元格内容的水平位置
align-items：设置单元格内容的垂直位置
place-items属性是align-items属性和justify-items属性的合并简写形式。
justify-content属性是整个内容区域在容器里面的水平位置align-content属性是整个内容区域的垂直位置
place-content属性是align-content属性和justify-content属性的合并简写形式。
grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。

grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。
grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。

**项目属性：**
grid-column-start：左边框所在的垂直网格线
grid-column-end：右边框所在的垂直网格线
grid-row-start：上边框所在的水平网格线
grid-row-end ：下边框所在的水平网格线
grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。
grid-area属性指定项目放在哪一个区域。
grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。

justify-self属性设置单元格内容的水平位置

align-self属性设置单元格内容的垂直位置

# 响应式布局

  优点：

  - 面对不同分辨率设备灵活性强；
  - 能够快捷解决多设备显示适应问题

  缺点：

  - 兼容各种设备工作量大，效率低下
  - 代码累赘，会出现隐藏无用的元素，加载时间长

  响应式界面的基本规则：媒体查询，边界断点的规则设定；内容的可伸缩效果；网格布局；主要内容呈现及图片的高质量

  - 可伸缩的内容区块：内容区块的再一定程度上能够自动调整，以确保填满整个界面
  - 可自由排布的内容区块：当页面尺寸变动较大时，能够减少或增加排布的列数
  - 适应页面尺寸的边距：到页面尺寸发生更大变化时，区块的边距也应该变化
  - 能够适应比例变化的图片：对于常见的宽度调整，图片在隐去两侧部分时，依旧保持美观可用
  - 能够自动隐藏/部分显示的内容：如在电脑上显示的的大段描述文本，在手机上就只能少量显示或全部隐藏
  - 能自动折叠的导航和菜单：展开还是收起，应该根据页面尺寸来判断
  - 放弃使用像素作为尺寸单位：用dp(对于前端来说，这里可能是rem)尺寸等方法来确保页面在分辨率相差很大的设备上，看起来也能保持一致。同时也要求提供的图片应该比预想的更大，才能适应高分辨率的屏幕

## 媒体查询

针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会格局浏览器的宽度和高度重新渲染页面
移动端优先首先使用的是min-width，PC端优先使用的max-width。

缺点：在浏览器大小改变前，需要改变的样式太多，代码繁琐

## 百分比布局

使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果

1. 子元素的height或width中使用百分比，是相对于子元素的直接父元素
2. 子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度；子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度
3. 子元素padding和margin如果设置成百分比，不论垂直还是水平方向都相对于直接父元素的width
4. border-radius设置为百分比则是相对于自身的宽度
   缺点：
   1. 计算困难
   2. 由于margin，padding以及widthheight的相对父元素对象不同则使得布局问题变得复杂**

## rem布局

rem是根据根元素font-size来决定元素大小的
布局思想：

1. 一般不要给元素设置具体的高度，但是对于一些小图标可以设定具体宽度值

2. 高度值可以设置固定值，根据设计稿进行

3. 所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值）

4. js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，将之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了

   缺点：必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，必须将font-size的代码放在css样式之前

## 视口单位

vw,vh与视图窗口有关，vw是相对于试图窗口的宽度
vw ：|相对于视窗的宽度，1vw 等于视口宽度的1%，即视窗宽度是100vw
vh ：|相对于视窗的高度，1vh 等于视口高度的1%，即视窗高度是100vh
vmin ：|vw和vh中的较小值
vmax ： vw和vh中的较大值
使用视口单位来实现响应式的做法：

1. 对于设计稿的尺寸转换单位，使用sass函数进行编译
2. 无论文本还是布局宽度，间距等都是用rem作为单位
3. 1物理像素线（也就是普通屏幕下1px,高清屏幕下0.5px的情况）采用transform属性scale实现
4. 对于需要保持宽高比的图应该用padding-top实现
5. 搭配vw和rem：因为失去了最大最小宽度的限制
   1. 给根元素大小设置随着视口变化而变化的vw单位，这样就可以实现动态改变其大小
   2. 限制根元素字体大小的最大最小值，配合body最大宽度和最小宽度

## 图片响应式

图片响应式两个方面：
\1. 大小自适应，保证图片在不同的分辨率下出现压缩，拉伸的情况
\2. 根据不同的屏幕分辨率和设备像素比来选择高分辨率的图片，从而减少网络带宽
**实现方式：**

1. 使用max-width：能够随着容器大小进行缩放

2. 使用srcset

3. 使用background-image
4. 使用picture标签

  ## 渐进增强vs优雅降级

  渐进增强：针对低版本浏览器进行构建页面，保证最基本功能，然后在针对高级浏览器进行效果，交互等改进和追加功能以达到更好的用户体验

  优雅降级：一开始就构建完整的功能，然后针对低版本浏览器进行兼容

  ## css像素和物理像素

  css像素：再js或者css代码中使用的px单位是css像素，是一个抽象单位

  物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的

  设备像素比dpr = 物理像素 / css像素

  ## 视口

  1. 布局视口

  2. 视觉视口：浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。视觉视口的定义，就像拿着一个放大镜分别从不同距离观察同一个物体，视觉视口仅仅类似于放大镜中显示的内容，因此视觉视口不会影响布局视口的宽度和高度。

  3. 理想视口：理想的布局视口

     | width         | 布局视口的宽度                    |
     | ------------- | --------------------------------- |
     | height        | 布局视口的高度                    |
     | initial-scale | 初始缩放比例，1表示不缩放，[0,10] |
     | minimum-scale | 最小缩放比例[0,10]                |
     | maximum-scale | 最大缩放比例[0,10]                |
     | user-scalable | 是否允许手动缩放页面，默认值为yes |

  ## 字体适配

  pc上最小font-size = 12px

  手机上最小font-size = 8px

# 两栏布局

- 左边浮动，右侧overflow：hidden
- 左边浮动，右边margin
- calc函数
- flex
- grid

#  display:none;visibility:hidden和opacity:0;

- 是否占据空间
  - **display:none;隐藏之后不占位置，**
  - visibility:hidden;opacity:0;隐藏后仍然占据位置
- 子元素是否继承
  - **display：none不会被子元素继承，父元素都不在了，子元素也不会显示出来**
  - visibility:hidden会被子元素继承，但是可以通过设置子元素visibility:visible来显示子元素
  - opaciity会被子元素继承，但是不能设置子元素opacity：0来重新显示
- 事件绑定
  - diaplay:none；的元素已经不在页面存在了，因此无法触发她绑定的事件
  - visibility:hidden不会触发他上面绑定的事件
  - **opacity：0元素上面绑定的事件是可以触发的**
- 过渡动画：transition对visibility:hidden和display：none是无效的，**对opacity有效**

# css如何针对不同浏览器做适应

- 浏览器css眼视光hi初始化normalize.css
- 浏览器兼容前缀
  - -o-://Opera
  - -ms-：//IE
  - -moz-：//firefox
  - -webkit：//chrome

# 从输入url页面加载发生了什么即浏览器渲染机制

浏览器渲染过程

- 对url解析：url只能是字母或者数字还有一些其他特殊符号（-_.~ ! * ' ( ) ; : @ & = + $ , / ? # [ ]，不转义的话会出现歧义。比如`http:www.baidu.com?key=value`,假如我的`key`本身就包括等于`=`符号，比如`ke=y=value`，就会出现歧义，你不知道`=`到底是连接`key`和`value`的符号，还是说本身`key`里面就有`=`。
  - 对url进行编码，URL编码只是简单的在特殊字符的各个字节前加上%
  
  - url编码的格式采用的是ascii码
  
  - DNS解析(网址=>ip地址)，计算机在互联网中唯一的标识是ip地址，DNS缓存：浏览器查找自身的dns缓存，判断缓存是否过期=》操作系统查找自身的dns缓存，读取本地的hosts的文件=》检查路由器缓存=》浏览器发起一个dns的系统调用进行迭代的解析：本地DNS服务器，根域名服务器，com顶级域名服务器，(二级域名)google.com域名服务器  https://juejin.cn/post/6844903590662766599
  
  - dns优化
  
    在html头部写入dns缓存地址`<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />`
  
- 查找是否有缓存
  
- tcp连接(三次握手）：

  - 第一次握手：主机a发送位码syn=1的tcp包给服务器，并且随机产生一个作为确认号，主机B收到syn码后直到a要建立连接
  - 第二次握手：主机B收到请求后，向A发送确认号（主机A的seq+1），syn=1，seq = 随机数 的TCP包；
  - 主机A收到后检查确认号是否正确，即第一次A发送的确认号是否+1了，以及位码ack是否为1，若正确，主机A会再发送确认号(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。![image-20211201211032078](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211201211032078.png)

- 发送http请求

- 服务端处理请求，并且返回http报文

- 浏览器解析和渲染页面：

  浏览器工作流程：构建DOM -> 构建CSSOM -> 构建渲染树 -> 布局 -> 绘制。

  - 浏览器通过http协议请求到服务器，获取到html样式后，自上而下进行解析，**构建dom树，document.readystate = "loading"**——正在加载
  - 遇到link外部css，创建线程记载，并继续解析文档
  - 遇到外部js，并且没有设置async或defer，浏览器阻塞并加载，等待js加载完成并执行该脚本，然后继续解析文档，对于设置async，defer的浏览器创建线程加载，并继续解析文档，async脚本加载完后立即执行
  - 遇到img，先正常解析dom架构，然后 浏览器异步加载src，并继续解析文档
  - **文档解析完成后，document.readystate =“interactive”**——可交互，并触发domcontentloaded事件，所有设置defer的脚本还会按顺序执行，dom树和cssom树进行关联形成渲染树——rendertree，并绘制在页面上
  - **所有defer的脚本加载完成并执行后，img等加载完成，document.readystate ="complete"**——完成,window对象触发事件。

- CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。

- 连接结束——四次挥手=>为什么三次不可以？简易理解：发完了，知道发完了，收完了，知道收完了

  - 客户端=>服务端	
  - 服务端=>客户端
  - 服务端=>客户端
  - 客户端=>服务端

将html文件转换为dom树：字节数据=>字符串=>Token=>Node=>Dom。token中会表示当前token是开始标签或结束标签或文本等信息。**有结束标签标识的Token不会创建节点对象**

构建cssom树：字节数据=>字符串=>Token=>Node=>cssom

CSSOM 提供了接口让JS动态操作 CSS，DOM 提供了接口让JS修改 HTML。cssom会阻塞页面渲染

document.readyState属性描述了document的加载状态
三种状态：

1. loading：正在加载
2. interactive：文档已经被解析，正在加载状态结束，但是图像，样式表或框架类的子资源仍在加载
3. complete：文档和所有子资源已完成加载，表示load状态的事件即将被触发

# 重绘和重排：重绘不一定引起重排，但重排必定重绘

重绘：当我们对dom的修改导致了样式的变化，却并未影响其几何属性，浏览器不需要重新计算元素的集合属性，直接为该元素绘制新的样式

重排/回流：当我们对DOM的修改引发了几何尺寸的变化时，浏览器需要重新计算元素的几何属性，其他元素的几何属性和位置也会因此受到影响，然后再将计算的结果绘制出来。

 **引起重排的属性和方法**：

- 添加或删除可见的dom元素
- 元素尺寸改变——边距，填充，边框，宽度和高度
- 内容变化
- 浏览器窗口尺寸改变——resize事件发生
- 计算offsetWidth和offsetHeight属性——元素布局宽高也就是除了margin
- 设置style属性的值

 **引起重绘的属性和方法**：

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\fc0f6415-e68b-41dc-89b1-69f8e227d925.png?t=1627294373520)

减少回流和重绘：

- 使用transform替代top
- 使用visibility替换display:none,因为前者值会引起重绘后者引发回流
- 不要把节点的属性值放在一个循环里当成循环里的变量。
- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
-  动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame——`你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行`  
- CSS 选择符从右往左匹配查找，避免节点层级过多——选择器少套
- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。

# 防抖和节流：限制执行频率

## 防抖

触发事件后在n秒内函数只能执行一次，如果在n秒内又触发了事件，则会重新计算函数执行时间。单位时间内，操作n次，选中最后一次。

特点：延迟==》无限后延，不断刷新定时器

```
// 防抖
function debounce(fn, delay) {
  let timeout = null;
  return function () {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn.apply(this, arguments);
    },delay)
  }
}
```

## 节流

连续触发事件但是在n秒内只执行一次函数，节流会稀释函数的执行频率。单位时间内，操作n次，执行第一次。

特点：只执行一次。设置标识位，看能不能触发事件

```
// 节流
function throttle(fn, delay) {
  let canrun = true;
  return function () {
    if (!canrun) return;
    canrun = false;
    setTimeout(() => {
      fn.apply(this.arguments);
      canrun = true;
    },delay)
  }
}
```

# 同步异步

同步：一条线程按顺序执行指令，当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情。当服务端做完了才返回到客户端。这样的话客户端需要一直等待。用户使用起来会有不友好。

异步：创建多条线程执行不同指令，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情，这样节约了时间，提高了效率。

# js浮点误差

计算机编程语言里的浮点数会存在精度丢失问题，根本原因是二进制和实现位数限制有些数无法有限表示。js以IEEE-754标准格式64位双精度浮点数形式存储数字类型，超出部分会舍去以下是十进制小数对应的二进制表示。IEEE-754标准是目前最广泛使用的浮点数运算标准

```
 *      0.1 >> 0.0001 1001 1001 1001…（1001无限循环）
 *      0.2 >> 0.0011 0011 0011 0011…（0011无限循环）
```

解决办法：

将小数放大为整数进行算数运算，再缩小为小数

# this指向

this指向执行环境也就是**指向最后调用它的那个对象**，在**标准函数**中，this引用的是把函数当成方法调用的上下文对象；在**箭头函数**中，this引用的是定义箭头函数的上下文。**当this遇到return时如果返回值是一个对象则this指向返回的对象，如果不是一个对象，this还是指向函数的实例，虽然null也是一个对象，但是其中的this还是指向函数的实例。**（在全局执行上下文中，this指向全局对象；在函数执行上下文中，this的值取决于该函数是如何调用的，如果被一个引用对象调用，那么this会被设置为那个对象，否则this的值被设置为全局对象或者undefined）

改变this指向：

- 可以通过call，bind，apply方式改变。
  - call()，第一个参数为函数内this的值，参数需要一个一个列出来
  - apply(),第一个参数为函数内this的值,第二个参数可以是Array的实例，也可以是arguents对象
  - bind()，会创建一个新的函数实例，其this值会被绑定到传给bind对象。例如，f.bind(obj)，实际上可以理解为obj.f()，这时，f函数体内的this自然指向的是obj，bind是创建一个新的函数，必须手动去调用
- 使用箭头函数
- 在函数内部使用_this = this，即使用变量保存下来
- new实例化一个对象

# new有什么作用，如何用代码实现new

1. 在内存中创建一个新对象
2. 这个新对象内部的[[prototype]]特性被赋值为构造函数的prototype属性
3. 构造函数内部的this被赋值为这个新对象(即this指向新对象)
4. 执行构造函数内部的代码（给新对象添加属性）
5. 如果构造函数返回空对象，则返回该对象；否则，返回刚创建的新对象

> new一个构造函数，创建一个新对象
>
> 将构造函数的原型对象绑定到新对象上，将构造函数的作用域给新对象——this指向这个新对象
>
> 执行构造函数的代码
>
> 返回新对象![image-20211130210050196](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211130210050196.png)

```
Function create(con,...args){
  var obj = {};
  obj._proto_ = con.prototype
  var result = con.apply(obj,args)
  return result instanceof object?result:obj // 判断是否为对象
}
var a = create(构造函数名称，需要传入的构造函数参数)
```

# 编程语言三个阶段

机器语言=》汇编语言=》高级语言

# js特点

- js是一种解释性脚本语言，代码不进行预编译；

  - 编译型语言：在代码**运行前**编译器将人类可以理解的语言装换成集器可以理解的语言，会先转成可执行文件
  - 解释型语言：将人类可以理解的语言转换成机器可以理解的语言，但是是在**运行时**转换的
  
- **跨平台**，在绝大多数浏览器的支持下，可以在多种平台下运行

- **弱类型**脚本语言：对使用的数据类型未作出严格要求，可以进行类型转换

- **单线程，事件驱动**：js对用户的响应，是以事件驱动的方式进行的。再网页中执行了某种操偶做所产生的动作，被称为事件。事件发生后，可能会引起响应事件响应，执行某些对应的脚本，这种机制被称为事件驱动

- **面向对象https://blog.csdn.net/jerry11112/article/details/79027834**

  ：将一切都看成是对象，而对象一般都由属性和方法组成。

  ​	面向过程可以看作是蛋炒饭，面向对象可以看作是盖浇饭。

  - 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；编程语言有：汇编语言，c语言等
    - 优点：编码流程化，便于分析
    - 缺点：**代码重用性低，扩展性差**
  - 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。编程语言有java，js，python等
    - 优点：代码结构分析，具备结构化；耦合度低，可重用，易扩展
    - 缺点：**性能低**(没有蛋炒饭香🤭)

- **安全性**：JavaScript是一种安全性语言，它不允许访问本地的硬盘，并不能将数据存入到服务器上，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互。从而有效地防止数据的丢失。

<img src="file://C:\Users\田甜圈\Documents\FocusNote\assets\b142d2a4-9986-4778-9adf-80157265e1ba.png?t=1627294373619" alt="img" style="zoom:50%;" />

# 浏览器内核

浏览器内核指的是浏览器的排版引擎，也称为浏览器引擎，页面渲染引擎或者样板引擎

其构成：

- **GUI渲染线程：**	
  - HTMLparse解析html
  - css parser解析style数据
  - layout过程，为每个可见节点的几何信息
  - painting过程，遍历rendertree调用ui接口绘制每个节点
- **js引擎线程**：负责解析js脚本，运行代码
- **定时器触发线程**：浏览器定时计数器并不是由js引擎技术的，因为js引擎是单线程的，如果出于阻塞状态就会影响计时的准确，因此通过单独线程来即使并触发计时
- **事件触发线程**：当一个事件被触发时该线程会把事件添加到处理队列的末尾，等待js引擎的处理
- **异步http请求过程**：XMLHttpRequest 请求会在浏览器中新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中

**Gecko**：早期被netscape和mozilla firefox浏览器使用 

**Trident**：微软开发，被IE4~IE11浏览器使用，但是edge浏览器已经转向blink。

**webkit**：苹果基于KHTML开发，开源的，用于safari，google chrome之前也在使用

**Blink**：是webkit的一个分支，google开发，目前应用于google chrome，edge，opera等

我们编写的js无论交给浏览器执行还是node执行，最后都是被cpu执行的，所以需要js引擎讲js代码翻译成cpu来执行

常见的js引擎：

- **spiderMonkey**：第一款js引擎
- **chakra**[ˈtʃʌkrə]：微软开发，用于it浏览器
- **jscore**：webkit中的js引擎，apple公司开发
- **v8**：google开发的js引擎

webkit由两部分组成：

- webcore：负责解析html，布局，渲染等
- jscore：解析，执行js代码

小程序中编写的js代码就是被jscore执行的

# v8引擎怎么实现的

- **parse将js代码转换成ast**（抽象语法树）

- **ignition[ɪɡˈnɪʃn] 会将ast转换为bytecode字节码同时会收集turbofan优化所需要的信息**(比如函数参数的类型信息)

- **turbofan是一个编译器，可以将字节码编译为cpu可以直接执行的机器码**。如果一个函数被多次调用，那么就会标记为热点函数，就会经过turbofan转换成优化的机器码，提高代码的执行性能；

  *机器码实际上也会被还原成bytecode，因为在后续执行函数的过程中，类型发生了变化，之前优化的机器码不能正确的处理，就会逆向转成字节码*![image-20211129154111156](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211129154111156.png)

  ![image-20211129154054767](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211129154054767.png)

# 作用域和执行上下文

词法作用域：作用域是由书写代码时函数声明的位置决定的。js使用的是词法作用域

动态作用域：作用域链是基于调用栈的，而不是代码中的作用域嵌套

变量或函数的上下文决定它可以访问哪些数据，以及他们的行为。作用域则保护内部的变量与环境不被外部访问，定义了变量的代码使用范围，避免命名冲突，为模块化开发提供了便利。

在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域一直向外串起所有包含函数的活动对象，直到全局上下文才终止。

全局上下文中的叫变量对象，他会在代码执行期间始终存在，而函数局部上下文中的叫活动对象，只在函数执行期间存在。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。

# 闭包	

**闭包指的是那些那些引用了另一个函数作用域中变量的函数。**

将执行环境想象为一个栈，栈底为全局执行环境，每检测到一个函数便将其执行环境入栈，由此栈顶的执行环境可以通过向栈底查找的方式寻找到本执行域总不存在的值。每执行一个函数便将其从栈中弹出，导致后续的函数无法访问被弹出函数内部的变量。**闭包就是将需要保存执行域的函数通过return的方式返回到外部并保存其函数执行域，使外部可以访问函数内部的值**

解决：
再退出函数之前，将不使用的全局变量全部删除，即手动接触引用赋值为null

作用：

- 模拟块级作用域，使用立即执行函数IIFE即可
- \2. 模块化，可以实现对私有变量的封装
- \3. 可以在函数外部读取到函数内部的变量、
- \4. 将内部变量始终保存在内存中

注：

- 引用变量可能会发生变化
- this指向问题，闭包函数是在window作用域下执行的，this指向window
- 内存泄漏问题：解决需要主动释放不需要的闭包
- 会污染全局变量

# 内存泄漏

不在用到的内存，没有及时释放就叫做内存泄漏。

产生原因：

- 意外声明全局变量。函数中的局部变量在函数执行结束之后这些变量已经不再被需要，所以垃圾回收会识别他们并释放，但是对于全局变量，垃圾回收器很难判断什么时候变量才不被需要，所以全局变量通常不会被回收。**在使用全局变量做持续存储大量数据的缓存时，需要设置存储上线并及时清理，不然的话数据量越来越大，内存压力也会越来越高**
- 定时器的回调函数中通过闭包引用了外部变量，定时器存在，则会产生内存泄露
- 使用js闭包
- 没有清理的dom元素引用：DOM 元素的生命周期正常是取决于是否挂载在 DOM 树上，当从 DOM 树上移除时，也就可以被销毁回收了
- 未清理的console.log输出

内存泄漏带来的影响：

- \1. 频繁GC——garbage collect，垃圾回收，gc会阻塞主进程的执行使得页面卡顿
- \2. 当内存不足以为某些对象分配所需要的空间，会导致程序崩溃，造成体验差

# 垃圾回收

找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。

执行环境负责在代码执行时管理内存，垃圾回收程序每个一定时间会自动运行，确定不再使用的变量并释放其内存。常见的两种标记策略：标记清理和引用计数。

weakset，weakmap是弱引用，即垃圾回收机制不考虑weakset对该对象的引用，如果其他对象都不在引用该对象，那么垃圾回收机制会自动回收改对象所占用的内存。

标记清理：当变量进入上下文，这个变量会被加上存在于上下文中的标记，当变量离开上下文时，也会被加上离开上下文的标记。eg：变量进入上下文时，反转某一位

引用计数：对每个值都记录他被引用的次数。声明变量并给他赋一个引用值时，这个值的引用数为1，如果同一个值又被赋给另外一个变量，引用数加1，如果保存该值引用的变量被其他值覆盖了，引用数减1。引用值为0时，就没办法再访问这个值了。

# 尾调用优化

尾调用指的是某个函数的最后一步是调用另一个函数，只能是直接调用。函数调用会在内存中产生调用帧，所有的调用帧会形成调用栈。尾调用优化即不保存之前的调用帧，只保存最内层的调用帧。

尾递归:函数调用自身称为递归，如果尾调用自身，则称为尾递归

# 箭头函数

- 箭头函数本身是没有prototype的，所以箭头函数本身没有this，箭头函数的this指向在定义的时候继承自外层第一个普通函数的this
- 不能通过new来进行调用
- 没有arguments

# js执行机制

js引擎执行过程分为三个阶段：

1. **语法分析**：分析该js脚本代码块的语法是否正确，如果出现不正确，则向外抛出一个**语法错误（SyntaxError）**，停止该js代码块的执行，然后继续查找并加载下一个代码块；如果语法正确，则进入预编译阶段

2. **预编译阶段**：创建go对象，找形参和变量声明，赋值为undefined；将实参和形参相统一；找函数声明并赋值函数体
   1. 运行环境：
   
      - 全局环境：js代码加载完毕后，进入代码预编译即进入全局环境
      - 函数环境：函数调用时，进入该函数环境，不同的函数则函数环境不同
      - eval：不建议使用，由安全，性能等问题
   
   2. 函数调用栈：使用栈存取的方式进行管理运行环境
   
   3. 创建执行上下文：
   
      1. **创建变量对象**：创建变量对象发生在预编译阶段，但尚未进入执行阶段，该变量对象都是不能访问的，因为此时的变量对象中的变量属性尚未赋值，值仍为undefined，只有进入执行阶段，变量对象中的变量属性进行赋值后，变量对象（Variable Object）转为活动对象（Active Object）后，才能进行访问，这个过程就是VO –> AO过程。vo：变量对象，存储了在上下文中定义的变量和函数声明，无法访问，必须是js中以var声明的变量才会记录在这里，let或者const声明的变量不会存在，必须是显式声明的函数，函数表达式不会被记录
         - 创建arguments对象，检查当前上下文的参数，建立该对象的属性与属性值，仅在函数环境(非箭头函数)中进行，全局环境没有此过程
         - 检查当前上下文的函数声明
         - 检查当前上下文的变量声明
         
      2. **建立作用域链**：作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。作用域链的第一项永远是当前作用域(当前上下文的变量对象或活动对象)，最后一项永远是全局作用域（全局执行上下文的活动对象）
      
      3. **确定this指向**
   
3. **执行阶段**：

事件循环：![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\6d22c898-8b54-4fab-8c1c-a3f54bae4bec.png?t=1627294373670)

首先，整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为同步任务，异步任务两部分，同步任务会直接进入主线程依次执行，异步任务会再分为宏任务和微任务，宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中。微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中。当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务，该过程不断重复。event table：异步流程

`await` 以前的代码，相当于与 `new Promise` 的同步代码，`await` 以后的代码相当于 `Promise.then`的异步

常见微任务：process.nextTick ()-Node；Promise.then()；catch；finally；Object.observe；MutationObserver

常见宏任务：主代码块；setTimeout；setInterval；setImmediate ()-Node；requestAnimationFrame ()-浏览器

# 前端缓存

## 浏览器存储

- cookie：cookie指的是某些网站为了识别用户身份而存储在用户本地中端的数据，cookie是服务端生成，客户端进行维护和存储。cookie以键值对的形式存储

  记住密码，下次自动登录，记录用户数据，广告推荐等

  cookie的缺点：

  - cookie不够大，**大小限制在4kb左右**，很多浏览器限制一个站点最多保存20个cookie(ie6或者更低版本)，ie7和之后的版本最多可以有50个cookie，firefox也可以有50个cookie，chrome和safari没有硬性限制
  - 过多的cookie会带来性能浪费
  - 不安全，http中cookie是明文传递的，所以具有安全问题

  HttpOnly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie， 所以为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。

- webstorage：为了解决客户端存储不需要频繁发送回服务器的数据时使用cookie问题

  - localstorage：永久存储机制，存储空间大，除非通过js删除，否则数据永远不会过期

    检测某一个网页下localStoragr的剩余容量
    使用json.stringify(localStorage).length和最大容量进行比较
    if(window.localStorage) {
      var aa= 1024 * 1024 * 5 - unescape(encodeURIComponent(JSON.stringify(localStorage))).length;
      console.log(aa);
    }

    - 为localstorage设置过期时间
    - 惰性删除：可以在每一次get的时候判断是否过期，过期就删除，但是可能有一些永远也不会用到，就永远不会删除。所以也可以采用刷新就删除。
    - 刷新删除：每次刷新进入页面就调用一次删除过期localstorage的函数

  - sessionstorage：只存储会话信息，数据会保存到浏览器关闭，存在sesionsrorage中的数据不受页面刷新影响，可以在浏览器崩溃后重启恢复

- indexdb：用于**客户端存储大量结构化数据**，该api使用索引来实现对该数据的高性能搜索，IndexedDB 是一个运行在浏览器上的非关系型数据库理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储**二进制**数据。

  - **采用键值对存储**
  - 异步，防止大量数据读写，拖慢网页
  - 支持事务：这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
  - **受到同源限制**
  - 存储空间大，理论上没有上限
  - 支持二进制存储

## http缓存

缓存的**优点**：减少不必要的数据传输，减轻服务器压力；加快客户端展示网页的速度，用户体验更友好

缓存的**缺点**：资源如果有更改但是客户端不进行更新造成用户获取信息滞后

一般用http头信息控制缓存

![image-20210810140652471](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210810140652471.png)

强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：<img src="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/img/all.jpg" alt="all" style="zoom: 67%;" />

缓存过程：

- 浏览器首次加载资源成功时，服务器返回200，此时除了下载资源之外将response的header一并缓存
- 下一次加载资源时，首先要经过强缓存的处理，cache-control的优先级最高，比如cache-control：no-cache,就直接进入到协商缓存的步骤了，如果cache-control：max-age=xxx,就会先比较当前时间和上一次返回200时的时间差，如果没有超过max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有cache-control，会取expires的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存
- 协商缓存阶段，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，服务器会比较Etag，如果相同，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200;
- 协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的If-Modified-Since的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200;
- ![image-20211130151808119](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211130151808119.png)

##  **强制缓存**：向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程

浏览器直接从本地获取数据，不与服务器进行交互，命中时http返回码为200，size显示为from cache，其通过http返回头中的Expires或者cache-Control（优先级高）来控制

- Expires指缓存过期时间，是服务器的具体时间点，其返回一个代表资源失效的时间

  缺点：失效时间是一个绝对时间，当客户端时间被修改或客户端与服务器时间偏差较大就会导致缓存混乱

- Cache-Control为相对客户端的时间，服务器与客户端时间偏差也不会有影响，其拥有一些字段
  - max-age：指定一个时间长度，在时间长度内资源有效（单位为s）
  - public：响应可以被任何对象（客户端，代理服务器）缓存
  - private：表明响应只能被单个用户缓存，代理服务器不能缓存
  - no-cache：该指令目的是为了防止从缓存中返回过期的数据，不是不缓存，客户端使用该指令表示客户端不接收缓存过的响应，缓存服务器必须把客户端请求发送给源服务器，服务器使用该指令时缓存服务器不能对该资源进行缓存
  - no-store：禁止缓存
  - Immutable：若页面命中强缓存，就算用户刷新页面，浏览器也不会发起服务请求

强制缓存的缓存规则：当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是**Expires**和**Cache-Control**，其中Cache-Control优先级比Expires高。[https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/](https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/)

## 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：**Last-Modified / If-Modified-Since和Etag / If-None-Match**，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

浏览器发送请求到服务器，服务器根据http头信息中的条件判断文件是否更改，如果未发生改变则返回304，浏览器从缓存中加载资源，改变则返回文件与状态码200。其通过两对值来判断文件是否被改变

- Last-modified/if-modified-since：

（1） Last-modified为浏览器向服务端发起请求后服务器放在响应头**返回的文件最后更改时间**

（2） If-modified-since即为被保存的last-modified值，其会在浏览器**协商缓存时被发送到服务器**，服务器通过读取这个字段并与文件最后改变时间比较，若相同则返回空，不同则将更新后的文件与文件最新更新时间返回至浏览器

**缺点：**last-modified保存的是精确到秒的绝对时间，如果资源在一秒内多次修改则无法识别。而且对于只修改了修改时间，并没有修改内容的文件也会去重新请求

- 弱Etag/if-none-match：  //强etag无论资源发生多细微的变化也会改变

（1） Etag为每个文件唯一存在的hash值

（2） 在浏览器向服务器发起请求时if-none-match字段会被设置为该文件的etag值，服务器在接收该字段后将其与本地文件的etag值对比，若一致则代表文件内容没有被改变

**缺点：**由于要生成hash所以性能较低

总结：etag精度更高且优先级大于last-modified，但是性能差于后者。同时配置时服务器优先验证etag，一致后才会验证last-modified·

- 协商缓存生效，返回304
- 协商缓存失效，返回200和请求结果

## 内存缓存from memory cache和硬盘缓存from disk cache

1、先查找内存，如果内存中存在，从内存中加载；
2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；
3、如果硬盘中未查找到，那就进行网络请求；
4、加载到的资源缓存到硬盘和内存；

内存缓存：快速读取和时效性

- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。
- 时效性：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。

## 启发式缓存

如果响应中未显示Expires，Cache-Control：max-age或Cache-Control：s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的2个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间。

```
// Date 减去 Last-Modified 值的 10% 作为缓存时间。
// Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间
  response_is_fresh =  max(0,（Date -  Last-Modified)) % 10
```

## session

session是保存在服务器的一种数据结构，是用户的唯一标识，用于跟踪用户状态。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。

## session与cookie的区别

- session是存储再服务端的，cookie是存储再客户端的
- session是基于cookie实现的，sessionid会存储再客户端的cookie中，session比cookie安全
- cookie只支持存字符串数据，想要设置其他类型的数，需要将其转换成字符串，session可以**存储任意数据类型**
-  Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- 存储大小不同：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源

## token

访问资源接口时所需要的资源凭证
简单token的组成：uid(**用户唯一的身份标识**)、time(**当前时间的时间戳**)、sign（**签名，**token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）

## token与session的区别

- Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。
- Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。**

## jwt  json web token

放在http请求头信息的authorization字段里，使用bearer模式添加jwt，跨域的时候讲jwt放在post请求的数据体里,通过url传输

# 函数柯里化

偏函数：局部应用固定一个函数的一个或者多个参数，也就是将一个n原函数转换成一个n-x元函数

[柯里化函数应用 | Heying Ye's Personal Website](https://heyingye.github.io/2018/04/20/柯里化函数应用/)

柯里化：把接受多个参数的函数变成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数

作用及特点

- **参数复用**——复用最初函数的第一个参数
- **提前返回**——返回接受余下的参数且返回结果的新韩淑
- **延迟执行**——返回新函数，等待执行

柯里化的应用

- 兼容浏览器事件监听方法，只进行一次兼容判断

```
var addEvent = function(ele, type, fn, isCapture) {
    if(window.addEventListener) {
        ele.addEventListener(type, fn, isCapture)
    } else if(window.attachEvent) {
        ele.attachEvent("on" + type, fn)
    }
}
// 柯里化后可以写成这样
var addEvent = (function() {
    if(window.addEventListener) {
        return function(ele, type, fn, isCapture) {
            ele.addEventListener(type, fn, isCapture)
        }
    } else if(window.attachEvent) {
        return function(ele, type, fn) {
             ele.attachEvent("on" + type, fn)
        }
    }
})()
```

- 性能优化：防抖节流
- 兼容低版本的IE的bind方法

封装简单柯里化函数：

```
function createCurry(fn) {
    if(typeof fn !== "function"){
        throw TypeError("fn is not function.");
    }
    //复用第一个参数
    var args = [].slice.call(arguments, 1);
    //返回新函数
    return function(){
        //收集剩余参数
        var _args = [].slice.call(arguments);
        //返回结果
        return fn.apply(this, args.concat(_args));
    }
}
```

# % 是求余，/是求模

# 数据类型——8种

基本数据类型：undefined，null——空对象指针，boolean，string，number，symbol，bigint

引用数据类型：object。object包括普通对象{}，数组对象[]，函数对象Function，正则对象RegExp，日期对象Date，数学对象Math

原始数据类型直接存储在栈中，占据空间小，大小固定
引用数据类型同时存储在栈和堆中，占据空间大，大小不固定，在栈中存储指针，该指针指向队中该实体的起始地址，堆中存储实体。

基本数据类型是**值传递**，即在拷贝时，会创建一个完全相等的变量，在栈中重新开辟一块内存空间存储原变量的副本。引用数据类型是**引用传递**，即在拷贝时，会创建一个指针指向原有变量，在栈中重新开辟一块内存空间存储指针以指向原变量。

- 0，+0，-0相除会返回NaN;分子为非零值，分母是有符号0或无符号0，则会返回infinity或-infinity

- 每个object实例都拥有的属性和方法：

  - constructor：用于创建对象的函数
  - hasOwnProperty(propertyName)：用于判断当前对象实例上是否存在给定的属性，要检查的属性名必须是字符串
  - isPrototypeof(object):用于判断当前对象是否为另一个对象的原型
  - propertyIsEnumerable(propertyName):用于判断给定的属性是否可以使用for—in语句枚举，要检查的属性名必须是字符串
  - toLocalString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境
  - toString():返回对象的字符串表示
  - valueof：返回对象对应的字符串，数值或布尔值表示

- ```js
  NaN * 任何数 => NaN
  infinity * 0 => NaN
  infinity * 非0的有限数值，则根据第二个操作符的符号返回infinity或-infinity
  infinity * infinity => infinity
  0 / 0 => NaN
  infinity / infinity => NaN
  任一操作数为NaN则返回NaN
  infinity + -infinity = NaN
  -0 + +0 => +0
  +0 - -0 => -0
  -0 - -0 => -0
  +0 === -0
  +0 === 0
  -0 === 0
  ```

- 检查超过两个值

  ```js
  function check(x,...rest){
      return Object.is(x,rest[0]) && (rest.length < 2 || check(...rest))
  }
  ```

# 判断数据类型

https://mp.weixin.qq.com/s/ahV0JsTzQirFNXBWjRDVoQ

**typeof**，instanceof，**constructor**，Object.prototype.toString.call，**Reflect.apply(Object.prototype.toString,val,[])**

typeof常用于检测 基本类型和 Function，除 null 外。

instanceof，**constructor**常用于检测 引用类型，无法区分基本类型。 

第四五种常用于检测 基本类型和引用类型。

1. **typeof** 返回一个字符串，表示未经计算的操作数的类型.用于区分基本数据类型，但无法区分null，无法区分引用数据类型，但能区分function.

   因为js的第一个版本，在这个版本中单个值在栈中占用32位的存储单元，32位存储单位又划分为(1~3位)和实际数据，类型标签存储在低位中，而null0~31位均为0，所以typeof会判断其为object

   typeof原理：不同的对象在底层都表示为二进制，在js中二进制前三位存储其类型信息
   
   - 000：对象
   - 010：浮点数
   - 100：字符串
   - 110：布尔值
   - 111：整数

![image-20210810111636124](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210810111636124.png)

2. object  **instanceof**  constructor ：**用来比较一个对象是否为某一个构造函数的实例**在运行时检测constructor.prototype是否存在于参数object的原型链上

   object：某个实例对象；constructor:某个构造函数

   **用于区分引用数据类型，不能用来检测基本数据类型**

   ```js
   function myInstanceofES5(object,constructor){
       var prototype = constructor.prototype    // constructor的显示原型
       object = object.__proto__ //object的隐式原型
       while(true){
       	if(object === null) return false
           if(prototype === object) return true
           object = object.__proto__
       }
   }
   const myInstanceofES6 = (object,constructor)=>{
       object == null 
           ? false 
       	: object == constructor 
           ? true 
       	: myInstanceof(myInstanceof.__proto__,constructor)
   }
   ```

3. **constructor**

   ```js
   /**
   * x是否为type类型
   **/
   const isXType = (x,type) => x.constructor.toString().indexOf(type) > -1
   ```

4. **Object.prototype.toString.call(val)**：将参数转化为字符串

   String(val)会依次调用val.toString(),val.valueOf()

5. **Reflect.apply(Object.prototype.toString,val,[])**

# 数据类型转换

## 字符串转数组

- split()
- Json.parse()
- 扩展运算符...
- Array.from()

## 数组转字符串

- join()
- toString(),toLocaleString(),String()

toLocaleString调用每个数组的oLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。toString()是保险的，返回唯一值的方法,它不会因为本地环境的改变而发生变化。如果是为了返回时间类型的数据，推荐使用toLocaleString()。

## 类数组转数组

类数组概念：类数组是具有length属性，但是不具备数组原型上的方法，常见的有arguments和dom操作返回的结果

- Array.from(类数组)
- Array.prototype.slice.call(类数组) //  由于类数组不具有数组原型上的方法，所以这样写，这样写可以将具有length的对象转为数组
- 扩展运算符：内部是for...of循环
- 使用concat。Array.prototype.cancat.apply([],类数组)

## 转换为数字

- Number():
  - true=>1,false=>0
  - 数值直接返回
  - null返回0
  - undefined返回NaN
  - 字符串
    - 字符串包含数值，包括数值字符前面带加减号的情况，则转换为一个十进制数值
    - 如果字符串包含有效的浮点值格式，则会转换为相应的浮点值
    - 字符串包含有效的十六进制格式，转换为十进制整数
    - 空字符串返回0
  - 除上述情况返回NaN
  - 对象，调用valueOf()方法，并按照上述规则转换返回的值，如果转换结果为NaN，则调用toString()方法，再按照转换字符串的规则转换
- parseInt()：字符串最前面的空格会被忽略，从第一个非空格字符串开始转换。如果第一个字符不是数值字符，加号或减号，parseInt()立即返回NaN。parseInt()的第二个参数用于指定底数，即按照第二个参数的进制转换为10进制

# undefined，unclared，null的区别

已在作用域中声明但还没有复制的变量是undefined
没声明过的变量是undeclared
null代表空对象

对于undeclared变量的引用，浏览器会报引用错误

其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

# == 和 ===

  ==会发生强制类型转换

  - 如果任一操作数为布尔值，将其转换为数值再比较
  - 如果一个操作符为字符串，另一个操作符为数值，则尝试将字符串转换为数值在比较
  - 如果一个操作数为对象，另一个操作数不是，则调用对象的valueOf()方法取得其原始值，再根据之前的规则进行比较
  - null == undefined,null和undefined不能再转换成其他类型的值再做比较
  - 任一操作符为NaN，则相等操作符返回false，不相等操作符返回false，NaN == NaN =》false
  - 如果两个操作符都为对象，则比较是否是同一个对象，如果都指向同一个对象，则相等操作符返回true

# 包装类

注：在通过new实例化引用类型后，得到的实例会在离开作用域时销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间

```js
var str="hello word";
 //var str = new String("hello world"); // 1.创建出一个和基本类型值相同的对象
 //var long = str.length; // 2.这个对象就可以调用包装对象下的方法，并且返回结给long变量
 //str = null;  //  3.之后这个临时创建的对象就被销毁了

 var long=str.length; //因为str没有length属性 所以执行这步之前后台会自动执行以上三步操作
 console.log(long);   // （结果为:10）

 //var str = new String("hello word"); // 1.因为下面有输出创建出str.length 而str不应该具有length这个属性 所以再次开辟空间创建出一个和基本类型值相同的对象
 //str.length=nudefined; // 2.因为包装对象下面没有length这个属性没有值，所以值是未定
 //str = null;  //  3.这个对象又被销毁了

   console.log(str.length) // （结果为:undefined）
```

步骤：

1. 创建一个基本类型对应的对象
2. 调用该实例上的特定方法
3. 销毁该对象即该实例

number,string,boolean构造函数可以与new操作符搭配，symbol，bigint使用call进行隐式装箱

```js
function createSymbolObject(description){
    return function (){
        return this
    }.call(Symbol(description))
}
function createBigIntObject(description){
    return function (){
        return this
    }.call(BigInt(description))
}
```

#  js内置对象

- 本地对象：与宿主无关，独立于宿主环境的ecmascript实现提供的对象，这些引用类型在运行过程中需要通过new来创建所需的实例对象
  包含object，array，date，regexp，function，boolean，number，string等
- 内置对象：与宿主无关，独立于宿主环境的ecmascript实现提供的对象，本身就是实例化内置对象，包含Global和Math，json
- 宿主对象：由ecmascript实现的宿主环境提供的对象，包含两大类，素数提供的以及自定义类对象，对于嵌入到网页中的js来说其宿主对象就是浏览器提供的对象例如window和document，所有的dom以及bom都属于宿主对象

# 数组方法 

![image-20211202122649746](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211202122649746.png)

改变原数组：

- push——返回数组新长度
- pop——返回被删除的项
- shift——返回删除项，删除第一个元素
- unshift——返回新数组长度
- reverse——反向排列
- splice——从数组中被删除的元素，三参：起始位置值，删除数量，添加的新元素
- sort——对数组新元素进行排序
- fill——批量复制。三参：填充的值，开始位置，结束位置
- copyWithin——填充数组。三参：复制到指定目标索引位置，元素复制的起始位置，停止复制的索引位置

# 检测数组

1. instanceof——用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
2. Array.isArray()
3. Object.prototype.toString.call()
4. constructor——属性返回数组的构造函数

# 数组扁平化——数组拍平

1. 使用flat()拍平数组：该方法可传入一个数字作为拍平的层数，默认为1，设置为infinity后可实现全部拍平

2. 使用正则表达式:

   Json.stringify(arr).replace(/\[|\]/g , ‘ ’).split(‘ , ’)  //  将数组转化为字符串后使用正则排除 [] 而后使用逗号分开,问题是数据类型会变为字符串

   改良后：

   Json.parse(‘[’+ json.stringify(arr).replace(/\[|\]/g ,‘ ’) + ‘]’) //转为字符串后拼接为数组样式最后将其转换为数组对象

3. 使用reduce：上一个返回值，当前元素，当前索引，原数组

   ```js
   var flat = (arr) => {
       return arr.reduce((pre,cur)=>{
           return pre.concat(Array.isArray(cur)?flat(cur):cur)// 递归连接数组
       },[])// 传入一个空数组作为累加的初始值
   }
   ```

4. 递归

   ```js
   const res = [];
   const fn = arr=>{
       for(let i = 0;i<arr.length;i++){
           if(Array.isArray(arr[i])){
               fn(arr[i])
           }else{
               res.push(arr[i])
           }
       }
   }
   
   ```

# 数组去重

1. ```js
   Array.prototype.unique = function(){
       var temp = {},
          	arr = [],
           len = this.length;
       for(let i = 0;i<len;i++){
           if(!temp[this[i]]){
               temp[this[i]] = "abc";
               arr.push(this[i]);
           }
       }
       return arr;
   }
   ```

2. indexof()——返回某个指定的字符串值在字符串中首次出现的位置

   ```js
   function unique(array){
       if(!Array.isArray(array)){
           console.log('type error');
           return ;
       }
       var res=[];
       var len = array.length;
       for(let i = 0;i<len;i++){
           let current = array[i];
           if(res.indexOf(current) === -1){
               res.push(current);
           }
       }
       return res;
   }
   ```

3. sort()_先将数组进行排序，然后判断当前元素与抢一个元素是否相同，相同说明重复，不相同就添加进res

   ```js
   function unique(array){
       array = array.sort();
       let res = [array[0]]
       for(let i = 0;i<len;i++){
           if(array[i] !== array[i-1]){
               res.push(array[i]);
           }
       }
       return res;
   }
   ```

4. 利用splice

   ```js
   function unique(array){
       let len = array.length;
       for(let i = 0;i<len;i++){
           for(let j = i+1;j<len;j++){
               if(arr[i] == arr[j]){
                   arr.splice(j,1);
                   j--;
               }
           }
           return arr;
       }
   }
   ```

5. ![image-20210810195004518](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210810195004518.png)

6. ![image-20210810195124840](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210810195124840.png)

7. map——返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值；按照原始数组元素顺序依次处理元素

   ![image-20210810195252859](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210810195252859.png)

# 懒加载&预加载

## 预加载

预加载简单来说就是将所有所需资源提前请求加载到本地，这样后面再需要用到时就直接从缓存获取资源
作用：
在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待事件，如果一个页面的内容过庞大，没有使用预加载技术的页面就会长时间的展现为一片空白

## 懒加载

懒加载也叫延迟加载，指的是再长网页中延迟加载图像，是一种很好优化网页性能的方式。

作用：

- 能提升用户体验
- 减少无效资源的加载
- 防止并发加载资源过度会阻塞js的加载

步骤：

- 加载loading图片
- 判断哪些图片要加载
- 隐形加载图片
- 替换真图片

  一张图片就是一个img标签，浏览器是否发起请求是根据img的src属性，懒加载的关键是在图片没有进入可视区域时，先不给img的src赋值，即浏览器不会发送请求![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524164645631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxNDE4ODk5NTMy,size_16,color_FFFFFF,t_70)

  四个步骤：

  - 加载loading图片
  - 判断哪些图片要加载
  - 隐形加载图片
  - 替换真图片

  ```js
  // onload是等所有的资源文件加载完毕以后再绑定事件
  window.onload = function(){
  	// 获取图片列表，即img标签列表
  	var imgs = document.querySelectorAll('img');
  	// 获取到浏览器顶部的距离
  	function getTop(e){
  		return e.offsetTop;
  	}
  	// 懒加载实现
  	function lazyload(imgs){
  		// 可视区域高度
  		var h = window.innerHeight;
  		//滚动区域高度
  		var s = document.documentElement.scrollTop || document.body.scrollTop;
  		for(var i=0;i<imgs.length;i++){
  			//图片距离顶部的距离大于可视区域和滚动区域之和时懒加载
  			if ((h+s)>getTop(imgs[i])) {
  				// 真实情况是页面开始有2秒空白，所以使用setTimeout定时2s
  				(function(i){
  					setTimeout(function(){
  						// 不加立即执行函数i会等于9
  						// 隐形加载图片或其他资源，
  						//创建一个临时图片，这个图片在内存中不会到页面上去。实现隐形加载
  						var temp = new Image();
  						temp.src = imgs[i].getAttribute('data-src');//只会请求一次
  						// onload判断图片加载完毕，真是图片加载完毕，再赋值给dom节点
  						temp.onload = function(){
  							// 获取自定义属性data-src，用真图片替换假图片
  							imgs[i].src = imgs[i].getAttribute('data-src')
  						}
  					},2000)
  				})(i)
  			}
  		}
  	}
  	lazyload(imgs);
  	// 滚屏函数
  	window.onscroll =function(){
  		lazyload(imgs);
  	}
  }
  
  ```

# 单位

  rem：根据网页的根元素来设置字体大小

  em：根据父元素的字体大小来设置

  vm/vh的出现很好的弥补了rem需要js辅助的缺点

  1vw = window.innerWidth 的1%

  1vh = window.innerHeight 的1%

# rgba()透明度和opacity透明度

rgba()只作用于元素的颜色或其背景

opacity作用于元素以及元素内所有内容的透明度

# 客户端渲染与服务端渲染

客户端渲染的页面是js负责进行的，html仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接以源文件的形式返回给客户端，然后根据html上的js生成dom插入html，而服务端渲染是服务器直接返回html让浏览器直接渲染，服务端在返回html之前，在特定的区域符号里用数据填充，再给客户端，客户端只负责解析html﻿﻿

![img](https://static.jkchao.cn/ssr5.png?imageMogr2/auto-orient/thumbnail/630x/blur/1x0/quality/75|imageslim)

客户端渲染的缺点：

- 首屏加载时间比较慢
- 服务端只支持beforeCreate和created两个钩子
- 对于seo优化不友好，搜索引擎爬虫只认识html结构的内容 

## 代码同构

- 服务端生成html
- 发送html给浏览器
- 浏览器接到内容显示
- 浏览器加载js文件
- js代码执行并接管页面的操作

## 数据注水

将服务端的store数据注入到window全局环境中

## 数据脱水

将window上绑定的数据给到客户端的store

# 创建对象

1. **工厂模式**：可以解决创建多个类似对象的问题，但没有解决对象标识的问题，即不知道对象是什么类型——所有实例都指向一个原型

```js
function create(name,age,job){
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        console.log(this.name);
    }
    return o;
}
let person1 = create('tyx',18,'doctor');
let person2 = create('tpf',19,'teacher');
```

2. **构造函数模式**：确保实例被标识为特定类型，但定义的方法会在每个实例上都创建一遍

```js
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        console.log(this.name);
    }
}
let person1 = new Person('tyx',18,'doctor');
let person2 = new Person('tpf',19,'teacher');
// 为了解决定义的方法会在每个实例上都创建一遍可以优化成如下代码；但如果需要多个方法，需要在全局作用域上定义多个函数
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName
}
function sayName(){
    console.log(this.name);
}
let person1 = new Person('tyx',18,'doctor');
let person2 = new Person('tpf',19,'teacher');
```

与工厂模式的区别：

- 没有显式的创建对象
- 属性和方法都直接赋值给了this
- 没有return

3. **原型模式**：原型对象上定义的属性和方法可以被对象实例共享，解决了构造函数中的问题.实例与构造函数的原型之间有直接的关系，但实例与构造函数之间没有,即person与Person.prototype之间有关系。再通过对象访问属性时，会按照这个属性的名称开始搜索，搜索开始于对象实例本身如果没有找到会在原型对象上继续查找

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019022822050917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzIyMDk3,size_16,color_FFFFFF,t_70)![img](https://mmbiz.qpic.cn/mmbiz_png/xPiamvPvWavdHGMyTCicShiaoic0XzUicIZIy6YCmpdCLorv61O2QdGmN3icXNPvWYZXK4xRfE2YyBGOTZREW07dG6SQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

``` js
function Person(){}
Person.prototype.name = 'tyx'
Person.prototype.age = 18
Person.prototype.job = 'teacher'
Person.prototype.sayName = function(){
    console,log(this.name);
}
let person1 = new Person();
let person2 = new Person();
person1.sayName();//'tyx'
person2.sayName();//'tyx'
```

4. **组合使用原型模式和构造函数模式**——原型模式创建方法，构造函数模式用于属性缺点：代码封装性一般

``` js
function Person(name,age){
	this.name = name;
	this.age = age;
}
Person.prototype = {
    constructor : Person
	sayname : function(){}
}
```

5. **动态原型模式**：只有在sayname（）不存在的时候才会将其放入原型，减少了新建时的操作；不能使用对象字面量重写prototype属性，否则原先在原型上的属性与方法会被覆盖，但是可以用delete操作符去掉实例与原型之间的联系

```js
function Person(){
    Person.prototype.age = 18;
    Person.prototype.name = 'tyx'
    if(typeof this.sayName != function){
        Person.prototype.sayName = function(){
            console.log('tyx');
        }
    }
}
```

6. **寄生构造函数模式**：（1） 返回的对象与构造函数或者构造函数的原型无关 （2）不能使用instanceof操作符判断对象类型

```js
function Create(name,age,job){
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        console.log(this.name);
    }
    return o;
}
let person1 = new Create('tyx',18,'doctor');
let person2 = new Create('tpf',19,'teacher');
```

7. **稳妥构造函数模式**：没有公共属性，而且其方法也不引用 this 的对象。无法识别对象所属类型。

```js
function Create(name,age,job){
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        console.log(name)
    }
    return o;
}
let person1 = Create('tyx',18,'doctor');
let person2 = Create('tpf',19,'teacher');
```

# 继承

1. **原型链继承**：引用值共享，改变引用值会影响所有实例；创建子类型实例时无法向超类型传参。构造函数.prototype = new 被继承构造函数![image-20210808172708927](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210808172708927.png)
2. **构造函数继承:**方法都在构造函数中定义，无法复用函数;在超类型中定义的方法，子类型中不可见![image-20210808172940498](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210808172940498.png)
3. **组合继承**：会调用两次构造函数              ![image-20210808173051812](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210808173051812.png)
4. **原型式继承**：引用值共享![image-20210808173241321](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210808173241321.png) 
5. **寄生式继承**：会因为不能做到函数复用而降低效率![image-20210808173334592](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210808173334592.png)
6. **寄生组合式继承**：![image-20210808173406819](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210808173406819.png)

# var,let与const

- var声明的变量存在变量提升的情况，let，const声明的变量不存在变量提升，只在let或const声明的代码块内有效
- let不允许在相同作用域内重复声明
- 存在暂时性死区，即在代码块内，let，const之前使用变量会报错
- const声明之后需要初始化，const声明的变量即指向其地址，修改地址会出错

## 为什么let，const不能重复声明

词法环境分为两个部分：
环境记录以及对外部词法环境引用
es6中存在全局环境变量记录Global Environment Records，其中包括两部分：

- object environment record：对象式环境记录：主要用于with和global的词法环境。
- declarative environment record：声明式环境记录。用来记录直接有标识符定义的元素，比如变量、常量、let、class、module、import以及函数声明。
  - function environment record：函数环境记录
  - module environment record：模块环境记录

函数声明和使用var声明的变量会添加进入Object Enviroment Record中。

使用let声明和使用const声明的变量会添加入Declarative Enviroment Record中。
使用了let和const声明时，引擎会同时检查Object Enviroment Record和Declarative Enviroment Record是否有该变量，如果有，则报错，否则将将变量添加入Declarative Enviroment Record中。

# js性能优化

1. 作用域链深层次对象局部化：如果某个跨作用域的值被引用一次以上，则将其存储于局部变量
2. 不改变执行时的作用域链：避免使用with语句，再catch语句中将错误委托给一个函数来处理，永远不要使用eval语句，如果一定要使用eval，用window.Function代替
3. 避免使用闭包
4. 对象深层次成员局部化：如果某个对象的属性被多次读取，则将属性值存储于局部变量
5. 适当在原型上增加方法：在实例调用方法时，若频繁创建实例，则应在原型上调用目标方法；若只创建一次，但需频繁执行内置方法，则应将目标方法创建于构造函数。
6. DOM方法代替innerHTML
7. 文档碎片增加节点：使用createDocumentFragment创建文档碎片，批量修改DOM，减少重排和重绘。
8. 事件绑定
9. 流程控制：4种循环类型：for，while，do-while，for-in，避免使用for-in，会搜索实例和原型，长生更多性能开销，唯一使用for-in的场景是迭代一个属性数量未知的对象
   1. 使用forEach循环：数据量较少时，优先使用forEach，其次是for，便秘那使用for-in，大量数据使用for
   2. switch总比if-else快：条件数量大时用switch，数量少时用if-else
10. 避免使用+=，因为会在内存中创建一个临时字符串，进行字符串操作后讲结果赋值给目标变量
11. 数组项合并推荐使用join
11. 提高加载性能。因为js下载会阻塞其他资源的下载，尽管脚本下载不会相互影响，但是页面必须等待所有js代码下载并执行完成才能继续，推荐将所有js文件放在body标签底部以减少对整个页面的影响



# 关于json的几个方法

json是一种轻量级的数据交换格式，完全独立于语言的文本格式

json中有两种结构：数组与对象

- 对象：

  ```js
  var packjson = {
      "name" = "tyx",
      "age" = "18"
  }
  ```

- 数组：

  ```js
  var packjson = [
      {
          "name":"tpf",
          "age":"19"
      },{
          "name":"tyx",
          "age":"18"
      }
  ]
  ```

json.parse(str)——字符串转对象

json.stringify()——对象转字符串

# dom事件流

什么是流：流是对输入输出设备的抽象，程序的角度说流是有方向的数据

事件流所描述的是从页面中接收事件的顺序

dom事件流三个阶段：

- 事件捕获
- 到达目标
- 事件冒泡

现在chrome使用的是事件冒泡处理事件流，如果使用事件捕获需将addeventlistener最后的参数设置为true，默认为false事件冒泡

阻止事件冒泡：event.stopPropagation()

**事件委托**：一般来讲，会把一个或者一组元素的事件委托到它的浮层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。

**事件冒泡**：event.stopPropagation()——阻止事件冒泡，事件的触发响应会从最底层目标一层层地向外到最外层（根节点）

**事件捕获**：事件会从最外层开始发生，直到最具体的元素。

# dom0，dom2，dom3

- dom0是通过onclick卸载html中的事件

​	清理该事件只需要给事件赋值null，同一个元素的同种事件只能绑定一个函数

- dom2是通过addeventlistener绑定的事件

清除时使用removeeventlistener
参数一为事件名，二为事件处理函数，第三个参数true表示捕获阶段，false为冒泡阶段

- dom3在dom2事件的基础上加了很多事件类型

# json

支持三种类型的值：

- 数组
- 对象
- 简单值：字符串，数值，布尔值和null，undefined不可以

json没有分号，json数据必须使用双引号

json.stringify()在序列化过程中会被跳过，可以有三个参数：

- 要序列化的对象
- 过滤器
- 用于缩进结果的json字符串的选项

# ajax

主要用于实现客户端与服务端的异步通信效果，实现页面的局部刷新

1. 创建xmlhttprequest异步调用对象
2. 创建一个新的http请求，并指定http请求的方法，url及验证信息
3. 设置响应http请求状态变化的参数
4. 发送http请求

   ```js
   var xhr 
   if (window.XMLHttpRequest) {　 // Mozilla, Safari...
     　xhr = new XMLHttpRequest();
   } else if (window.ActiveXObject) { // IE
     　try {
       　xhr = new ActiveXObject('Msxml2.XMLHTTP');
    　 } catch (e) {
     　  try {
       　  xhr = new ActiveXObject('Microsoft.XMLHTTP');
      　 } catch (e) {}
    　 }
   }
   xhr.open('method','url'，'async');//配置请求，初始化设置请求方法和url
   xhr.send();//构建请求体，发送到服务器
   xhr.setRequestHeader('Content-Type','application/json');//设置请求头
   //事件绑定，处理服务端返回的结果
   xhr.onreadystatechange = function(){
       if(xhr.readyState === 4){[
           if(xhr.status >= 200 && xhr.status < 300){
      			// some code         
           }
       ]}
   }
   ```

readyState的状态从0到4变化

- 0：请求未初始化，xmlhttprequest对象还没有完成初始化
- 1：服务器连接已建立，xmlhttprequest对象开始发送请求
- 2：请求已接收，xmlhttprequest对象的请求发送完成
- 3：请求处理中，xmlhttprequest对象开始读取服务器的响应
- 4：请求已完成且响应就绪，xmlhttprequest对象读取服务器响应结束

# axios与ajax的区别

- axios是通过promise实现的对ajax技术的一种封装，支持promise所有的api
- 浏览器盒node端都可以使用，浏览器中创建xmlhttprequest
- 支持请求响应拦截器
- 自动转换json数据
- 客户端防止csrf

## promise封装ajax

```js
const getJson = function(url){
    return new Promise(function(resolve,reject){
        const handler = fucntion(){
            if(this.readyState !== 4){
                return;
            }
            if(this.status == 200){
                resolve(this.response);
            }else{
                reject(new Error(this.statusText));
            }
        };
        const client = new XHRHttpRequest();
        client.open('GET',url);
        client.onreadystatechange = handler;
        client.responseType = 'json';
        client.setRequestHeader('Accept','application/json');
        client.send();
    });
    return promise;
}
getJson("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
```

# 跨域

跨域是为了防止用户读取到另一个域名下的内容，ajax可以获取响应，浏览器认为不安全，所以拦截了响应。
同源策略：是一种约定，浏览器最核心最基本的安全功能，如果缺少了同源策略，浏览器容易受到xss，csrf等攻击，同源指的是协议+域名+端口三者相同，即便两个不同的域名指向同一个ip地址，也非同源

限制内容：

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求发送后，结果被浏览器拦截了

但是有三个标签是允许跨域加载资源：

- <img src=XXX>

- <link href=XXX>

- <script src=XXX>

注：
1.如果协议和端口造化的跨域问题前台是无能为力的
\2. 在跨域问题上，仅仅是通过url首部来识别而不会根据对应的ip地址是否相同来判断。url首部可以了理解为协议，域名和端口必须匹配


CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案

JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

不管是Node中间件代理还是nginx反向代理，主要是**通过同源策略对服务器不加限制。**

日常工作中，用得比较多的跨域方案是cors和nginx反向代理

## jsonp

利用<script>标签没有跨域限制的漏洞，网页可以得到其他	来源的动态产生的json数据，jsonp请求一定需要对方的服务器做支持才可以
jsonp实际上就是请求一段js脚本，将这段脚本的结果当作数据
创建一个script标签，再把需要请求的api地址方法到src里

网页通过添加一个<script>元素，向服务器请求json数据，服务器收到请求后，将数据放在指定的回调函数里传回来

jsonp与ajax相比：
都是客户端向服务端发送请求，从服务端获取数据的方式，但ajax属于同源策略，jsonp属于非同源策略

优缺点：
简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题，缺点是仅支持get方法具有局限性，不安全可能会受到xss攻击，难以确定jsonp请求是否失败，可以通过使用定时器指定响应的允许时间，超出时间认为相应失败

## cors

服务端设置**Access-Control-Allow-Origin** 就可以开启 CORS。盖属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源

简单请求：
条件一：使用get/post/head
条件3二：Content-Type的值为text/plain或multipart/form-data或application/x-www-form-urlencoded

复杂请求：
复杂请求得cors会在正式通信前，增加一次http请求，成为预检请求，该请求是option方法得，通过该请求来指导服务端是否允许跨域请求

- 使用put或delete
- 发送json格式的数据
- 请求中带有自定义头部

## postmessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，允许来自不同源得脚本采用异步方式进行有限的通信，可以实现跨文档，多窗口，跨域消息传递。它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

otherWindow.postMessage(message, targetOrigin, [transfer]);

## websocket

https://juejin.cn/post/7020964728386093093

h5提供的一种浏览器与服务器进行**全双工通信**的网络技术，属于**应用层**协议。

1. 单向通信/单工通信：只能由一个方向的通信而没有反方向的交互
2. 双向交替通信/半双工通信：通信双发都可以发送信息，但不能双方同时发送
3. 双向同时通信/**全双工通信**：通信双发可以同时发送和接收信息

特点：

（1）建立在 TCP 协议之上，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）**可以发送文本，也可以发送二进制数据。**

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

一些api：

- webSocket.onopen：连接成功后的回调函数
- webSocket.onclose：用于指定连接关闭后的回调函数
- webSocket.onmessage:用于指定收到服务器数据后的回调函数
- webSocket.send():用于想服务器发送数据

## 原理

具体实现是通过http协议建立通道，然后再此基础上使用websocket协议进行通信。

过程：

客户端发起http请求，经过三次握手之后，建立起tcp链接，http请求里存放websocket支持的版本号信息，如：Upgrade、Connection、WebSocket-Version等；然后，服务器收到客户端的握手请求后，同样采用http协议反馈数据，最后，客户端收到连接成功的消息后，开始借助于tcp传输信道进行全双工通信。

## 断线重连

当客户端第一次发请求至服务端时会携带唯一标识，以及时间戳，服务端到db或者缓存去查询该请求的唯一标识，如果不存在就存入db或者缓存中

第二次客户端定时再次发送请求依旧携带唯一标识，以及时间戳，服务端到db或者缓存中去查询该请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前的时间戳减去上次的时间，得出的毫秒数判断是否大于指定的时间，小于的话就是在线，否则就是离线

断线原因：

- websocket超时没有消息自动断开连接
- websocket异常包括服务端出现中断，交互切屏等等客户端异常中断等等
  - 解决方法:引入reconnecting-websocket.min.js

**解决：**

- 修改nginx配置信息
- websocket发送心跳包
  - 客户端每隔一个时间间隔发生一个探测包给服务器
  - 客户端发包时启动一个超时定时器
  - 服务器端接收到检测包，应该回应一个包
  - 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器
  - 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了

## node中间件代理

实现原理：
同源策略式浏览器需要遵循的标准，而如果服务器向服务器请求就毋须遵循同源策略。代理服务器需要做以下几个步骤：
\1. 接收客户端请求
\2. 将请求转发给服务器
\3. 拿到服务器响应数据
\4. 将相应转发给客户端

## nginx反向代理

搭建一个中转ngnix服务器，用于转发请求，使用nginx反向代理实现跨域是最简单的跨域方式，只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能】

实现：
通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

 使用反向代理最主要的两个原因：
 1）安全及权限。可以看出，使用反向代理后，用户端将无法直接通过请求访问真正的内容服务器，而必须首先通过Nginx。可以通过在Nginx层上将危险或者没有权限的请求内容过滤掉，从而保证了服务器的安全。
 2）负载均衡。例如一个网站的内容被部署在若干台服务器上，可以把这些机子看成一个集群，那么Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上（内部模块提供了多种负载均衡算法），从而实现服务器压力的负载均衡。
3）nginx还带有健康检查功能（服务器心跳检查），会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态，一旦发现某台服务器异常，那么在以后代理进来的客户端请求都不会被发送到该服务器上（直到后面的健康检查发现该服务器恢复正常），从而保证客户端访问的稳定性。

## window.name+iframe

name值在不同的页面加载后依旧存在，并且可以支持非常长的name值

## location.hash+iframe

实现原理：
a.html欲与c.html跨域相互通信，通过中间页b.html来实现，不同域之间利用iframe的location.hash船只，相同域之间直接js访问来通信

## document.domain+iframe

该方式值用于二级域名相同的情况下。
实现原理：两个页面都通过js强制设置document.domain为基础主语，就实现了同域

## 为什么需要预检请求

复杂请求可能对服务器数据产生副作用，所以在请求之前需要先请求服务器，当前网页所在域名是否在服务器的许可名单中，服务器允许后，浏览器才会发出正式请求，否则不发送

# class是如何实现的

class中的constructor对应的是构造函数，this关键字代表实例对象；class底层其实还是构造函数，class内部的方法都是不可枚举的。class类必须使用new进行调用，否则会报错

## class底层实现原理即babel是如何编译的

# 前端异步解决方案

https://blog.csdn.net/qq_32442973/article/details/89322763

- promise

- 回调函数

  优点：简单，容易理解和部署

  不利于代码的阅读和维护，各部分之间的代码耦合，流程比较乱，每个人物只能指定一个回调函数

- 事件监听

  采用时间驱动模式，任务的执行不取决代码的顺序，取决于某一个事件是否发生

  优点：比较容易理解，可以绑定多个事件，每一个事件可以指定多个回调函数，可以耦合，偶遇利于模块化

  缺点：整个程序都要变成事件驱动型，运行流程不清晰

- generator函数

- async await

- nodejs中nextTick setImmidata

# symbol

- 原始数据类型
- 通过symbol函数生成，可以作为属性名
- 不可以使用new命令
- 接受一个字符串作为参数，表示对symbol实例的描述；如果参数式对象则通过tostring将其转为字符串；相同参数的symbol函数的返回值是不相等的
- 不能与其他类型的值进行运算，可以显示转换为字符串，也可以转换为布尔值，但是不能转为数值
- 可以通过descriptioin直接返回symbol的描述——**ES10**
- 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
- 不能使用点运算符
- 还可以使用定义一组常量，保证这组常量的值是不相等的
- symol作为属性名，遍历对象的时候不会出现在for...in和for...of循环中，也不会被Object.keys(),Object.getOwnPropertySymbols()，JSON.stringify()返回，但是他也不是私有属性，Object.getOwnPropertySymbols()可以获取对象的所有Symbol属性名，该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
- Reflect.ownKeys()也可以返回所有类型的键名，包括常规键名和symbol键名
- **Symbol.for()——接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。**

# set&weakset

set

- 类似于数组，但是元素不能重复
- 创建set需要通过set构造函数
- size属性可用于返回set中元素的个数
- 常用方法
  - add(value)：添加某个元素，返回set对象本身
  - delete(value)：从set中删除和这个值相等的与元素，返回boolean类型
  - has(value)：判断set中是否存在某个元素，返回boolean类型
  - clear()：清空set中所有元素，没有返回值
  - forEach(callback,[,thisArg])：同故宫forEach遍历set
  - 支持for...of

weakset

- 只能存放对象类型，不能存放基本类型
- 对元素的引用是弱引用，gc会回收
- weakset不能遍历
- 常用方法
  - add(value)：添加某个元素，返回weakset对象本身
  - delete(value)：从weakset中删除和这个值相等的与元素，返回boolean类型
  - has(value)：判断weakset中是否存在某个元素，返回boolean类型
- 应用场景：不能使用非构造方法创建出来的对象调用running方法![image-20211128124631965](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211128124631965.png)

# map&weakmap

map

- 用于存储映射关系，对象存储映射关系只能用**字符串**作为属性名，map可以使用其他类型作为属性名
- size属性可用于返回map中元素的个数
- 常见方法
  - add(value)：添加某个元素，返回map对象本身
  - delete(value)：从map中删除和这个值相等的与元素，返回boolean类型
  - has(value)：判断map中是否存在某个元素，返回boolean类型
  - clear()：清空map中所有元素，没有返回值
  - forEach(callback,[,thisArg])：同故宫forEach遍历map
  - 支持for...of

weakmap

- key只能使用对象，不接受其他类型作为key
- 对元素的引用是弱引用，gc会回收
- 常见方法：
  - set(key,value)：在map中添加key，value，并且返回整个map对象
  - get(key)：根据key获取map中的value
  - has(key)：判断是否包括某一个key，返回boolean类型
  - delete(key)：根据key删除一个键值对，返回boolean类型
- 应用场景：![image-20211128125651922](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211128125651922.png)

# proxy

在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

es6原生提供proxy构造函数，生成proxy实例

```javascript
var proxy = new Proxy(target, handler);
```

# promise

https://juejin.cn/post/6945319439772434469

promise对象是一个构造函数，用来生成promise实例

```js
const promise = new Primise(function(resolve,reject){
   // some code
    if(异步操作成功){
        resolve(value);
    }else{
        reject(error)
    }
})
promise.then(function(value){
    //success
},function(error){
    //failure
})
```

promiase主要解决多个异步操作导致多个回调函数嵌套所产生的回调地狱，主要作用是使回调变的可控且标准，将异步操作以同步操作的流程表达出来

1. 三种状态：
   1. pending：进行中
   2. fulfilled：已成功
   3. rejected：已失败
   
2. 缺点：
   1. 无法取消promise，一旦新建立即执行，无法中途取消
   2. 如果不设置回调函数，promise内部抛出的错误，不会反映到外部
   3. 当处于pending状态时，无法知道当前进展到哪一阶段。是刚刚开始还是即将完成
   
3. resolve函数的作用：将promise对象的状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去

4. reject函数的作用：将promise对象的状态从未完成变成失败，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去

5. `then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，第二个回调函数是`Promise`对象的状态变为`rejected`时调用。then方法是定义在原型对象Promise.prototype上的.它的作用是为promise实例添加状态改变时的回调函数。

6. **promise新建后立即执行**

7. 一般来说不要再then()方法里面定义reject状态的回调函数，总是使用catch方法

   ```js
   // bad
   promise
     .then(function(data) {
       // success
     }, function(err) {
       // error
     });
   
   // good
   promise
     .then(function(data) { //cb
       // success
     })
     .catch(function(err) {
       // error
     });
   ```

8. 跟传统的`try/catch`代码块不同的是，如果没有使用`catch()`方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。

- **promise.prototype.then()**——为 Promise 实例添加状态改变时的回调函数，返回的是一个新的promise实例

- **promise.prototype.catch()**——是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数。

- **promise.prototype.finally()**——方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。

- **promise.all()**——`Promise.all()`方法接受一个数组作为参数，`p1`、`p2`、`p3`都是 Promise 实例，如果不是，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 Promise 实例，再进一步处理。另外，`Promise.all()`方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。**彼此相互依赖，其中任何一个被 `reject` ，其它都失去了实际价值**

  - 只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。

  - 只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。

  如果作为参数的 Promise 实例，自己定义了`catch`方法，那么它一旦被`rejected`，并不会触发`Promise.all()`的`catch`方法。

- **Promise.race()**——只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数。

- **Promise.allSettled()**——一组异步操作都结束，不管每一个操作是成功还是失败，在进行下一步操作。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是`fulfilled`还是`rejected`），返回的 Promise 对象才会发生状态变更。**适用于彼此不依赖，其中任何一个被 `reject` ，对其它都没有影响，期望知道每个 `promise` 的执行结果**

- **Promise.any()**——只要参数实例有一个变成`fulfilled`状态，包装实例就会变成`fulfilled`状态；如果所有参数实例都变成`rejected`状态，包装实例就会变成`rejected`状态。`Promise.any()`不会因为某个 Promise 变成`rejected`状态而结束，必须等到所有参数 Promise 变成`rejected`状态才会结束。

# class

- 一个类只能有一个构造函数
- 调用构造函数发生的事情：
  - 在内存中创建一个对象
  - 将类的原型prototype赋值给创建出来的对象moni.__proto\_\_ = Perosn.prototye
  - 将对象赋值给函数的this：new绑定
  - 执行函数体的代码
  - 自动返回创建出来的对象
- js引擎在解析子类的时候有要求，如果我们有实现继承，那么子类的构造方法中，在使用this之前需要使用super（）或者在return之前调用super()

![image-20211128150303999](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211128150303999.png)

# iterator 和for...of循环

- 是一种接口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署iterator接口，就可以完成遍历操作

- 主要为for...of循环消费，当使用for...of循环遍历某种数据结构时，该循环会自动去寻找iterator接口，使得数据结构的成员能够按某种次序排列

- 遍历过程：

  - 创建一个指针对象，指向当前数据结构的起始位置，遍历器对象本身就是一个指针对象
  - 第一次调用只针对象的next方法，可以将指针指向数据结构的第一个成员
  - 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。
  - 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。

- next方法返回的对象，具有value和done两个属性，`value`属性返回当前位置的成员，`done`属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用`next`方法。

- 调用iterator接口的场合

  - 解构赋值
  - 扩展运算符
  - Array.from()
  - yield*
  - for...of
  - Promise.all()
  - Promise.race()

- return()：如果for...of循环提前退出（通常是因为出错或者有break语句），就会调用return（）方法，如果一个对象在遍历前完成，需要清理或释放资源，就可以部署return（）方法，**return()方法必须返回一个对象**

- for...of循环会正确识别32位UTF-16字符

- **for...of和for...in循环**

  for...in循环只能获得**键名**，不能获取键值，为遍历对象设计。目的是枚举对象属性，该语句**在原型链中上升，会枚举继承的属性。**不能保证保留元素顺序 **大多数用于对象**
  for..of允许遍历获得键值，可以与break，continue，return配合使用，**不能遍历对象**

# generator

genertor函数是一个状态机，封装了多个内部状态，执行generator函数会返回一个遍历器对象，该对象可以依次遍历 Generator 函数内部的每一个状态。

- yield表达式

  运行逻辑：

  - 遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。
  - 下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。
  - 如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。
  - 如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

- 当generator函数不适用yield语句时，是一个单纯的暂缓函数

- yield表达式只能使用在generator函数中使用，其他地方使用会报错

- `yield`表达式本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。

# co模块

用于generator函数的自动执行

genertor函数只要传入co函数，就会自动执行。

co模块返回一个promise对象，co先检查参数是否为genertor函数，如果是，就执行该函数，的得到一个内部指针对象；如果不是就返回，并阿静promise对象的状态改为resolved。接着，co 将 Generator 函数的内部指针对象的`next`方法，包装成`onFulfilled`函数。这主要是为了能够捕捉抛出的错误。

#  bigint

es11之前MAX_SAFE_INTEGER   9007199254740991

ES11之后使用bigint在数后面加上n

# 深浅克隆

https://www.jianshu.com/p/35d69cf24f1f

**深克隆**

主要是将一个对象的属性拷贝并存储至自己开辟的内存区域，不受外界干扰：

- 判断是不是原始值
- 判断是数组还是对象instanceof/toString/constructor
- 建立相应的而数组或对象
- 递归

**方法**：

- json.parse(json.stringify)
  - 对象中不能有函数，否则无法序列化，会被忽略
  - 对象中不能有undefined，否则无法序列化，会被忽略
  - 对象中不能有正则，否则无法序列化，克隆后为空
  - date数据类型会被转化成字符串类型
  - 对象不能是环状结构，否则会报错

- 库函数lodash
- 手写递归

  ```js
  function deepClone(origin,target){
      var target = target || {},
     	    toStr = Object.prototype.toString,
          arrStr = "[Object Array]";
      for(let prop in origin){
          if(origin.hasOwnProperty(prop)){
              if(origin[prop]!=="null" && typeof(origin[prop]) == "object"){
                  if(toStr.call(origin[prop])== arrStr){
                      target[prop] = [];
                  }else{
                      target[prop] = {};
                  }
                  deepClone(origin[prop],target[prop]);
              }else{
                  target[prop] = origion[prop];
              }
          }
      }
      return target;
  }
  function deepClone(target,cache = new Map()){
    if(cache.get(target)){
        return cache.get(target)
    }
    if(target instanceof Object){
        let dist ;
        if(target instanceof Array){
          // 拷贝数组
          dist = [];
        }else if(target instanceof Function){
          // 拷贝函数
          dist = function () {
            return target.call(this, ...arguments);
          };
        }else if(target instanceof RegExp){
          // 拷贝正则表达式
         dist = new RegExp(target.source,target.flags);
        }else if(target instanceof Date){
            dist = new Date(target);
        }else{
          // 拷贝普通对象
          dist = {};
        }
        // 将属性和拷贝后的值作为一个map
        cache.set(target, dist);
        for(let key in target){
            // 过滤掉原型身上的属性
          if (target.hasOwnProperty(key)) {
              dist[key] = deepClone(target[key], cache);
          }
        }
        return dist;
    }else{
        return target;
    }
  }
  ```

**浅拷贝**

值复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存，但深拷贝会另外创造一个一模一样的对象，新对象与源对象不共享内存，修改新对象不会改到原对象。

**方法**：

- object.assign()——当object只有一层时，是深拷贝。用于将所有可枚举属性的值从一个或多个元对象分配到目标对象，返回目标对象
- Array.prototype.concat()
- Array.prototype.slice()

```js
//浅
function clone(origin,target){
    var target = target || {};//如果用户不提供子集提供
    for(let prop in origin){
        target[prop]=origin[prop];
    }
    return target;
    
}
```

# ES7~ES12

https://juejin.cn/post/6844903811622912014#heading-30

## ES7

- 数组includes()方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。
- a ** b指数运算符，它与 Math.pow(a, b)相同

## ES8

- async/await
- Object.values()
- Object.entries()
- String padding: `padStart()`和`padEnd()`，填充字符串达到当前长度
- 函数参数列表结尾允许逗号
- `Object.getOwnPropertyDescriptors()`
- `ShareArrayBuffer`和`Atomics`对象，用于从共享内存位置读取和写入

# 设计模式

设计模式为代码设计经验的总结，使用色痕迹模式的目的是可重用代码，代码更容易被人理解，保证代码可靠性

六大原则：

- 单一原则：一个类或一种方法值对应一种职责，尽量做到类只有一个行为原因引起变化
- 里氏替换原则：子类可以扩展符类的功能，但不能能改变父类原有的功能，增强程序健壮性
- 依赖倒置原则：面向接口编程(接口作为参数实现应用场景)变量或是传参传参数尽量使用抽象类或接口
- 接口隔离：建立单一接口，复杂的接口根据业务分成多个简单接口
- 迪米特原则：最少知道原则，尽量减少代码的耦合，尽量减少与其他实体发生相互作用，是的系统功能模块相对独立
- 开闭原则：用抽象创建架构，用实现扩展原则

常见的设计模式：

- 单例模式
- 工厂模式
- 策略模式：要实现某一个功能，有多种方案可以选择，定义策略，将其每一个都封装起来，并且使他们可以相互转换
- 代理模式
- 观察者模式
- 模块模式
- 构造函数模式
- 混合模式
- 发布订阅模式：消息的发布者不会将消息直接发送给特定的订阅者，而是通过消息通道广播出去，然后订阅者通过订阅获取到想要的消息
- 装饰器模式：是为了给一个函数赋能，增强它的某种能力，它能动态的添加对象的行为，也就是我传入的就是一个对象
- 适配器模式：为了解决我们不兼容的问题，把一个类的接口换成我们想要的接口。

# Vue生命周期

https://vue3js.cn/interview/vue/lifecycle.html#%E4%B8%89%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B

1. beforecreate——创建前。在实例初始化以后，数据观测data observer和event/watcher事件配置之前被调用。当前阶段data,methods,computed以及watch上的方法和数据都不能被访问
2. created——创建完成。实例已经创建完成后被调用。在这一步，实例已完成以下配置：数据观测，属性和方法的运算，watch/event事件回调。这里没有$el，如果非想要与Dom进行交互，可以通过vm.$nextTick来访问dom
3. beforemount——挂载前。在挂载开始之前被调用：相关的render函数首次被调用
4. mounted——挂载完成。在挂载完成后发生，在当前阶段，真实的dom挂载完毕，数据完成双向绑定，可以访问到dom节点
5. beforeupdate——更新前。数据更新时调用，发生在虚拟dom重新渲染和patch之前，可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程
6. update——更新完成。当前阶段dom已完成更新，避免自此期间更改数据，因为会导致无限循环的更新，该钩子在服务器端渲染期间不被调用
7. beforedestory——销毁前。在这一步实例仍然完全可用。我们可以在这是进行善后首位工作，比如清除定时器
8. destroyed——销毁完成。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。

9. activated——被keep-alive缓存的组件激活时调用
10. deactivated——被keep-alive缓存的组件停用时调用

数据请求在createrd和mountd的区别：

created是在组件实例一旦创建完成的是后台调用，这时候页面`dom`节点并未生成`mounted`是在页面`dom`节点渲染完毕之后就立刻执行的触发时机上`created`是比`mounted`要更早的两者相同点：都能拿到实例对象的属性和方法讨论这个问题本质就是触发的时机，放在`mounted`请求有可能导致页面闪动（页面`dom`结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在`create`生命周期当中

**异步请求在钩子函数created，beforeMount，mounted中进行异步请求，这三个钩子函数中data已经创建，可以将服务端返回的数据进行赋值**

如果异步请求不需要依赖dom，推荐在**created**钩子函数中调用异步请求，因为在create钩子函数中调用异步请求有一下优点：

- 能更快的获取到服务端数据，减少页面loading事件
- ssr——服务端渲染不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

 # vue核心特性

- 遵循mvvm原则

  # mvvm，mvc，mvp

  https://juejin.cn/post/6844903508521680909#heading-13

  https://juejin.cn/post/6961222829979697165

  http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html

  M层不是数据模型，而是业务模型——所有业务数据和业务实现逻辑都应定义在m层，而且业务逻辑的实现与当以与具体的界面无关

  1. mvvm：<img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210815225628442.png" alt="image-20210815225628442" style="zoom:50%;" /><img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210815225854337.png" alt="image-20210815225854337" style="zoom:50%;" />

     m:数据保存

     v：用户界面

     vm：v与vm的绑定器

     特点：与mvp模式基本相似，唯一的区别是使用双向绑定，V的变动自动反应到VM，反之亦然

  2. mvc：当我们用js代码更新model时，view就会自动更新

     <img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210815225616863.png" alt="image-20210815225616863" style="zoom:50%;" /><img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210815225825540.png" alt="image-20210815225825540" style="zoom:50%;" />

     m：数据保存

     v：用户界面

     c：业务逻辑——controler，当用户对 View 有操作时它负责去修改相应 Model；当 Model 的值发生变化时它负责去更新对应 View。

     通信方式：都是单向的

     1. 用户将指令通过v或者直接传送到c
     2. c完成业务逻辑后要求m改变状态
     3. m将新数据发送到v，用户得到反馈

  3. mvp<img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210815225802266.png" alt="image-20210815225802266" style="zoom:50%;" />

     m：数据保存

     v：用户界面

     p：v与m交互中间件

     通信方式：

     1. 当视图接收到来自用户的事件时，会将事件转交给 Presenter 进行处理；

     2. 被动的视图实现presentr的代理，当需要更新视图时 Presenter回调代理来更新视图的内容，这样让presenter专注于业务逻辑，view专注于显示逻辑

     3. Presenter 负责对模型进行操作和更新，在需要时取出其中存储的信息；

     4. 当模型层改变时，可以将改变的信息发送给观察者 Presenter；

     特点：

     1. 各部分通信是双向的
     2. v与m不泛生通信，通过p传递
     3. v非常薄，不部署任何逻辑，被称为被动试图，p非常厚，所有逻辑都在这里

- 简介，体积小，运行效率高

- 响应式编程，组件化

  组件化可以**降低整个系统的耦合度**，在保持接口不变的情况下，可以替换不同的组件快速完成需求；

  调试方便，由于整个系统是通过组件组合起来的，出现问题的时候，可以使用排除法直接移出组件，或快速定位问题源头

  提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级

- 数据与结构分离，虚拟dom

# 模板编译原理

vue的编译过程就是将template转化为render函数的过程，
第一步是将模板字符串转换成element ASTs
第二步是对ast进行静态节点标记，主要用来做虚拟dom的渲染优化
第三步是使用element ASTs生成render函数代码字符串

# 单页应用&多页应用

单页应用：只有一个主页面的应用，浏览器在一开始时就要加载所有的html,css,js

单页应用优点：

- 用户体验好，内容的改变不需要加载整个页面，对服务器压力小
- 前后端分离
- 完全的前端组件化，代码组织方式更加规范，便于修改

单页应用缺点：

- 首次加载需要大量的静态资源
- 不利于seo优化，数据在前端渲染，意味着没有seo
- 页面导航不可用，需自行实现前进和后退

多页面：包含多个页面，跳转时全部刷新

- **多页应用的首屏时间快**：当法访问网页的时候，服务器返回一个新的html文档，只经过了一个http请求
- **搜索引擎优化效果好**： 搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别html内容的，而我们每个页面所有的内容都放在Html中，所以这种多页应用，seo排名效果好。
- 切换慢：每次跳转都需要发出http请求

## 给单页应用做seo优化

1. 服务端渲染

2. 静态化

   1. 一种是通过程序将动态页面抓取并保存为静态页面，这样的页面实际存在于服务器的硬盘中
   2. 通过web服务器的url rewrite方式。通过web服务器内部模块按一定的规则而将外部的url请求转化为内部的文件地址

3. 使用phantonjs针对爬虫处理。原理是通过`Nginx`配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个`node server`，再通过`PhantomJS`来解析完整的`HTML`，返回给爬虫。下面是大致流程图

   ![img](https://static.vue-js.com/25be6630-3ac7-11eb-ab90-d9ae814b240d.png)

# vue项目打包优化

https://juejin.cn/post/7004045635620405278

https://juejin.cn/post/6844904071896236040

1. 路由懒加载

2. 分析包大小：终端中运行npm run preview -- --report，这个命令会从我们的入口`main.js`进行依赖分析，分析出各个包的大小。最终会在生成的`dist`文件夹下生成一个`report.html`的文件，打开后就可以看到我们在项目使用文件占据的空间大小啦~

3. webpack配置排除打包：将一些不常用的包，排除在生成的打包文件以外

   在vue.config.js中添加externals项

4. 引用网络资源：

   - cdn：内容分发网络，用它来提高访问速度，将一些静态资源，css，js，图片或者视频放在第三方的cdn服务器上，可以加快访问速度

     在开发环境时，文件资源还是可以从本地`node_modules`中取出，而只有项目上线了，才需要去使用外部资源。此时我们可以使用**环境变量**来进行区分。

5. 打包去除console.log

6. 关闭资源地图productionSourceMap

   首先，由于最新版的脚手架`不自带配置文件`了，先在根目录新建`vue.config.js`文件，关闭`productionSourceMap`，在`vue.config.js`中写入如下内容

   ```javascript
   module.exports = {
       productionSourceMap: false
   }
   ```

7. 开启Gzip压缩：

   安装插件`compression-webpack-plugin`，打开代码压缩，`npm install --save-dev compression-webpack-plugin`，现在的`vue.config.js`代码如下，但是，需要注意的是，**服务器上nginx也必须开启gzip才能生效**

8. 代码压缩，先安装插件`npm i -D uglifyjs-webpack-plugin`，然后在最上方引入依赖
9. 图片压缩`npm install image-webpack-loader --save-dev`

10. 首屏骨架屏优化
11. 关闭预先加载模块，`vue-cli` 默认开启 `prefetch` (预先加载模块)，提前获取用户未来可能会访问的内容
12. `nginx配置缓存`

# comuted&watch&methods

**computed**：当页面中某些数据依赖其他数据进行变动时可以使用该属性

- 支持缓存，计算完成的值在相关值不发生改变的时候可重复复用。比如刷新的时候会重新计算，使用method会重新进行计算

- 惰性求值：即使相关值已经改变，它也只会在调用时求值

- 不支持异步，但是可以使用 **vue-async-computed**插件讲promise的值绑定到组件属性来创建和使用组件中的异步计算属性

  标准计算属性与异步属性的区别：

  - 异步属性不能有setter
  - 直到promise的resolve为止，除非default被设置，否则该值位null

- 适用于一个数据收多个数据影响的场景

- 默认只有getter，可以自定义设定setter

**wacth**：用于观察和监听页面上的vue实例，适用于数据变化的同时需要进行异步操作的场景

- 不支持缓存，数据变化时立即触发回调函数中的操作
- 支持异步
- 使用于一个数据影响多个数据的场景
- 监听数据必须是data中声明过的或prop中的数据，其处理函数有两个参数immediate（组件加载立即触发回调函数执行）与deep（深度监听）

# v-for&v-if

v-for优先级比v-if高，最好不要一起使用

可以使用计算属性解决或在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环

# v-show和v-if

v-if是条件渲染，确保在切换过程中条件块内的事件监听器和子组件适当的被销毁和重建

v-if是惰性的，如果在初始渲染条件为假，则什么而也不做，直到条件第一次变为真时，才会开始渲染条件块

v-show不管条件是什么，元素总是被渲染，并且是简单的基于css进行切换

`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

v-show由false转为true时不会触发组件的生命周期

v-if由false转为true的时候，触发组件的`beforeCreate`、`create`、`beforeMount`、`mounted`钩子，由`true`变为`false`的时候触发组件的`beforeDestory`、`destoryed`方法

## 原理

- 将模板template转为ast结构的 js对象
- 用ast得到的js对象拼装render和staticRenderFns函数
- render和staticRenderFns函数被调用后生成虚拟vnode节点，该节点包含创建dom节点所需信息
- vm.patch函数通过虚拟dom算法利用vnode节点创建真实dom节点

# vue实例挂载的过程

- new Vue的时候会调用_init方法

  - 定义 `$set`、`$get` 、`$delete`、`$watch` 等方法

  - 定义 `$on`、`$off`、`$emit`、`$off`等事件

  - 定义 `_update`、`$forceUpdate`、`$destroy`生命周期

- 调用$mount进行页面的挂载
- 挂载的时候主要是通过`mountComponent`方法
- 定义`updateComponent`更新函数
- 执行`render`生成虚拟`DOM`
- `_update`将虚拟`DOM`生成真实`DOM`结构，并且渲染到页面中

对template的解析步骤：

- jianghtml文档片段解析成ast描述负
- 将ast描述符解析成字符串
- 生成render函数

# 为什么在html中监听事件

使用v-on的几个好处:

- 能在html模板轻松定位在就是代码里对应的方法
- 无需再js中手动绑定事件，viewmodel代码是非常纯粹的逻辑，和dom完全解耦，更易于测试
- 当一个viewmodel被销毁时，所有的事件处理器都会被自动删除，无需担心如何清理

# cookie，session，webstorage

https://www.cnblogs.com/zr123/p/8086525.html

1. **cookie**：客户端保存用户信息的一种机制，用来记录用户的一些信息
   - 定义：http cookie，用于在客户端存储会话信息，纯文本的形式。浏览器会存储这些会话信息。这些发送回服务器的额外信息可用于唯一标识发送请求的客户端。
   - cookie是与特定域绑定的，设置cookie后，他会与请求一起发送到创建它的域。这个限制能保证cookie中存储的信息只对被认可的接收者开放，不被其他域访问
   - 客户端设置cookie ：重复执行document.cookie = "key=name"
   - 构成：
     - 名称，不区分大小写，需经过url编码
     - 值：存储在cookie里的字符串值，这个值必须经过url编码
     - 域：cookie有效的域，发送到这个域的所有请i去都会包含对应的cookie
     - 路径：请求url中包含这个路径才会把cookie发送到服务器
     - 过期时间：表示何时删除cookie的事件戳
     - 安全标志：设置之后，只适用ssl安全连接的情况才会把cookie发送到服务器
   - cookie缺点:
     - 每个域名下cookie数量有限
     - 存储空间太小，只有4kb
     - 每次http请求都会发送至服务器，影响小欧律
     - 需要自行封装增删改查的方法
   - cookie什么时候会被销毁：
     - Max-age：以秒为单位，cookie会在Max-age秒之后，被删除，当Max-age为负数的时候，表示的是临时存储，不会生成cookie文件，只会存在浏览器内存中，且只会再打开浏览器窗口或者子窗口有效，一旦浏览器关闭就会消失，当Max-age为0时，就会删除cookie
2. **session**：session是保存在服务器的一种数据结构，是用户的唯一标识，用于跟踪用户状态。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。
3. **webstorage**——浏览器本地存储

为了解决通过客户端存储不需要频繁发送回服务器的数据时使用cookie问题。

两个目标：

- 提供在cookie之外的存储会话数据的途径
- 提供跨会话持久化存储大量数据的机制

1. sessionstorage：只存储会话信息，数据会保存道浏览器关闭，存在sessionstorage中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复
2. localstorage：永久存储机制，存储空间大，除非通过js删除，否则数据永远不会过期

#  为什么data是一个函数

组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就返回一份新的data，类似于给每个组件实例创建了一个私有的数据空间，让各个组件实例维护各自的数据。单纯携程对象形式，使得所有组件实例共用了一份data，会造成一个变了全都变了的结果

# 响应式原理

**通过数据的改变去驱动dom视图的变化**

数据劫持+观察者模式

对象内部通过defineReactive方法，使用object.defineProperty将属性进行劫持（只会劫持已经存在的属性）。数组则是通过重写数组方法进行实现。当页面使用对应属性时，每个属性都拥有自己的dep属性，存放其依赖的watcher（依赖手机），当属性变化后会通知自己对应的watcher去更新

vue不会触发试图更新：

1. 在实例创建之后新的属性到实例上
2. 直接更改数组下标来修改数组的值

当给对象新增不存在的属性，首先会把新的属性进行响应式跟踪，然后会触发对象————__ob__的dep收集到的watcher去更新，当修改数组索引时我们调用数组本身的splice方法去更新数组

**数组和对象值变化时如何劫持到**：

对象内部通过defineReactive方法，使用Object.defineProperty属性进行劫持（只会劫持存在的属性），数组通过重写数组方法实现（pop,push,unshift,shift,splice,sort,reverse）
多层对象通过递归进行劫持，所以当对象层级过深时，性能变差

![image-20210607021557820](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/404f033ac36f47a7896e73beb469ae2c~tplv-k3u1fbpfcp-watermark.awebp)

对于对象而言，每一次的数据变更都会对对象的属性进行一次枚举，一般对象本身的属性数量有限，所以对于遍历枚举等方式产生的性能损耗可以忽略不计，但是对于数组而言呢？数组包含的元素量是可能达到成千上万，假设对于每一次数组元素的更新都触发了枚举/遍历，其带来的性能损耗将与获得的用户体验不成正比，故vue无法检测数组的变动。

this.$set(要更改的数据源，要更改的具体数据，重新赋的值)——**向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性**

# 双向绑定

https://www.jianshu.com/p/f194619f6f26

**除了数据驱动dom之外，dom的变化反过来影响数据，是一个双向的关系**

双向绑定流程：

- new Vue()初始化，对data执行响应化处理，在observer函数中劫持监听所有属性

- 同时对模板执行编译，找到其中动态绑定的数据，从`data`中获取并初始化视图，这个过程发生在`Compile`中

- 同时定义⼀个更新函数和`Watcher`，将来对应数据变化时`Watcher`会调用更新函数

- 由于`data`的某个`key`在⼀个视图中可能出现多次，所以每个`key`都需要⼀个管家`Dep`来管理多个`Watcher`

- 将来data中数据⼀旦发生变化，会首先找到对应的`Dep`，通知所有`Watcher`执行更新函数

  ![img](https://static.vue-js.com/e5369850-3ac9-11eb-85f6-6fac77c0c9b3.png)

利用proxy或者object.defineproperty生成的observer劫持监听所有的属性，在属性变化后通知dep订阅者。同时compile解析指令，收集指令所依赖的方法和数据,等待数据变化然后进行渲染，将来data中数据⼀旦发生变化，会首先找到对应的`Dep`，触发setter通知之前的所有`Watcher`执行更新函数，告知视图更新，重新渲染页面

# vue中给对象添加新属性页面不刷新

vue不允许在已经创建的实力上动态添加新的响应式属性

- Vue.set（）通过`Vue.set`向响应式对象中添加一个`property`，并确保这个新 `property`同样是响应式的，且触发视图更新

- Object.assign()直接使用`Object.assign()`添加到对象的新属性不会触发更新

- $forceUpdated()  如果你发现你自己需要在 `Vue`中做一次强制更新，99.9% 的情况，是你在某个地方做错了事

  `$forceUpdate`迫使`Vue` 实例重新渲染

## vue.set()和this.$set()的区别

Vue.set()和this.$set()这两个api的实现原理基本一模一样，都是使用了set函数。set函数是从 ../observer/index 文件中导出的，区别在于Vue.set()是将set函数绑定在Vue构造函数上，this.$set()是将set函数绑定在Vue原型上。

this.$set(要更改的数据源，要更改的具体数据，重新赋的值)——**向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性**

# vue nextTick()——本质是一种优化策略

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。

实现原理：

vue是异步执行dom更新的，一旦观察到数据变化，vue就会开启一个队列，将同一个事件循环中观察到数据变化的watcher推送进这个队列，如果这个watcher被触发多次，只会被推送到队列一次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和 DOm 操作，而在下一个事件循环时，vue会清空队列，并进行必要的dom更新。

- 将回调函数放入callbacks等待执行
- 将执行函数放到微任务或者宏任务中
- 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调

使用场景

- 在created钩子函数进行的dom操作一定要放在vue.nextTick()的回调函数中。

  原因是在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载已完成。

- 点击按钮显示原本v-show = false 隐藏起来的输入框，并获取焦点。

# vue-router 

## 路由守卫

记住参数或者查询的改变并不触发进入或离开的导航守卫

router.beforeEach——**全局前置守卫**，当一个导航触发时，全局前置守卫按照创建顺序调用，守卫是异步解析执行，此时导航在所有守卫resolve完之前一直处于等待中

router.beforeResolve——**全局解析守卫**，当导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用

router.afterEach——**全局后置钩子**，不会接收next函数也不会改变导航本身

组件内的守卫：

- beforeRouteEnter(to,from,next){}——在渲染该组件的对应路由被confirm前调用，不能获取组件实例this
- beforeRouteUpdate(to,from,next){}——在当前路由改变，但是该组件被复用时调用，可以访问组件实例this
- beforeRouteLeave(to,from,next){}——导航离开组件的对应路由时调用

## 完成的导航解析流程们可以访问组件实例this

1. 导航被触发
2. 在失活的组件里调用beforeRouteLeave守卫
3. 调用全局的beforeEach守卫
4. 在重用的组件里调用beforeRouteUpdate守卫
5. 在路由配置里调用beforeEnter
6. 解析异步路由组件
7. 在被激活的组件里调用beforeRouteEnter
8. 调用全局的beforeResolve守卫
9. 导航被确认
10. 调用全局的afterEach钩子
11. 触发dom更新
12. 调用beforeRouteEnter守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入

## 路由元信息

meta字段，通过$route.matched来检查路由记录中的meta字段

## 数据获取

- **导航完成之后获取**：先完成导航，然后再接下来的组件生命周期钩子中获取数据，在数据获取期间显示加载中之类的指示。使用该方式会马上导航和渲染组件，然后在组件的created钩子中获取数据（我们可以在数据获取期间站是一个loading状态）
- **导航完成之前获取**：导航完成之前，在路由进入的守卫中获取数据，在数据获取成功后执行导航

## 导航故障

NavigationFailureType可以帮助开发者来区分不同类型的导航故障

- redirected：在导航守卫中中调用了next(newLocation)重定向到了其他地方
- aborted：在到行首为重调用了next(false)中断了本次导航
- cancelled：在当前导航还没有完成之前就有了一个新的导航
- duplicated：盗汗隔壁组织，因为我们已经在目标位置了

**导航故障的属性：**

所有的导航故障都会有to和from属性，分别表示这次失败的导航的饿目标位置和当前位置

## hash&history

当选择mode类型后，程序回根据选择的mode类型创建不同的history对象(hash:HashHistory;history:HTML5History)

1. hash模式（带#）

   #后面hash的值的变化不会向服务器发起请求且请求时值会发送#之前的url，每次hash值发生变化就会触发hashchange事件，可以监听hashchange（window.hashchange）实现页面部分内容操作。

   核心通过监听url中hash来进行路由跳转

   **两个方法**：

   this.$router.push()——将新路由添加到浏览器访问历史的栈顶

   this.$router.replace()——替换掉当前栈顶的路由

2. history模式：核心使用html5 history api

   **修改历史状态**：pushState(),replaceState(),popState()——改变url地址且不会发送请求，可以读取历史记录栈，还可以对浏览器历史记录栈进行修改

   **切换历史状态**：back()——后退,forward()——前进,go()——跳转

3. hash与history的区别

   hash模式中修改的是#中的信息，浏览器请求不会讲#之后的数据发送到后台，但是在history模式下，可以自由修改path，当刷新时，如果服务器没有响应的相应或者资源，则会刷新出来404页面

## $router与$route的区别

1. $route从当前router跳转对象里面可以获取name,path,query,params等（<router-link>传的参数由 this.$route.query或者 this.$route.params 接收）
2. $router为VueRouter实例，想要导航到不同url，则使用$router.push方法，返回上一个history也是使用$router.go方法

#  vue组件通信

1. props和$emit父组件向子组件传递数据是通过prop传递的，子组件数据传递给父组件是通过$emit触发事件来做到的
2. $parent,$children获取当前的父组件与当前组件的子组件
3. $attrs和$listeners
4. 父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量(官方不推荐在实际业务中使用，但是写组件库时很常用)
5. $refs来获取组件实例
6. vuex状态管理
7. $eventBus兄弟组件数据传递，事件总线

- 父组件向子组件传值：

  - 父组件在子组件标签中加入:子组件接收值=“父组件传输参数”，子组件在export dafault中加入props:[“子组件接收值”]接收传递的值，后续使用子组件接收值使用父组件传递的参数
  - 需要注意的是vue组件的数据是单向流通的，子组件不允许对父组件传过来的值直接进行修改，此处传过来的值直接就是动态的

- 子组件向父组件传值：

  - 子组件绑定一个事件，通过this.$emit()触发

    子组件在事件触发执行函数时加入this.$emit('传到父组件绑定的名称'，’参数‘)

    父组件在子组件标签上绑定@传到父组件绑定的名称=“父组件自己的函数”

    **此处的事件名和曾需要与组件中绑定的事件名称一致**

  - 父组件传给自组建一个回调函数，子组件执行这个回调函数

    父组件定义一个回调函数callback(value){this.$value=value}

    通过:fcallback="callback"传给子组件

    子组件通过props:{fcallback:Funciton}的方式获取到该函数，而后通过调用该回调函数实现子对父的传参

  - 通过$parent/$children或$emit访问组件实例

    父组件在子组件标签中加入ref=“name”而后使用this.$refs.name.function()或this.$children.function()来调用子组件的函数

    **这种方式的组件通信不能跨级**

- **爷组件向孙组件传值**

  - 使用$props依次传递
  - 使用vuex
  - 使用$attrs

- ***\*孙传祖传值**

  $listeners

# vue内置指令

![内置指令.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b46ec8b051246858211c4c7ec129fb3~tplv-k3u1fbpfcp-watermark.awebp)

# vue单向数据流

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件

# vuex是怎么实现的

**vuex利用了vue的mixin机制，混合 beforeCreate 钩子 将store注入至vue组件实例上，并注册了 vuex store的引用属性 $store！**

在beforeCreate钩子函数中，通过vue 的mixin机制。——即每个vue组件实例化过程中，会在beforeCreate钩子前调用vuexInit方法，this指向vue实例

mixin：混入，一个混入对象可以包含任意组件选项，当组件使用混入对象时，所有混入对象的选项将被混合进入该组件本身的选项

# vuex中的数据在页面刷新之后数据消失

- 用sessionstorage或者localstorage存储数据

- 引入插件vuex-presist

# vuex中状态是对象时，注意什么？

对象是引用类型，复制后改变属性还是会影响元数据，这样会改变state里面的状态，是不允许，所以先用深克隆复制对象，在修改

# action和mutation有什么区别？

- action提交的是mutation，而不是直接变更状态，mutation可以直接变更状态
- action可以包含任一异步操作，mutation只能是同步操作
- action是通过dispatch进行提交，而mutation是通过commit进行提交
- 接收参数不同，mutation第一个参数是state，而action第一个参数是context

# 首屏加载白屏

首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容

## 原因

1. 网络延迟
2. 资源文件体积是否过大
3. 资源是否重复发送请求去加载
4. 加载脚本的时候，渲染内容堵塞

## FP,FCP,FMP

fP:加载html。首次绘制，代表浏览器第一次向屏幕传输像素的事件，也就是页面在屏幕上首次发生视觉变化的时间

FCP:加载静态资源css，js之后解析html，生成html浏览器在第一次像屏幕绘制内容，只有首次绘制文本，图片，非白色的canvas或svg时才算做fcp

FMP：ajax请求数据之后，首次有效绘制。表示页面的主要内容发开始出现在屏幕上的时间点，是测量用户加载体验的主要目标

从FP到FMP这个过程是白屏

## 解决方法

1. 预渲染：

   webpack打包时候渲染，通过无头浏览器

   无头浏览器,打包的时候，可以把你index.html的内容放入你这个浏览器，但是你这个浏览器是空白的，然后当你进入页面时候直接加载这个index.html，但是没ajax请求

2. 同构：一套代码多端使用

3. ssr

4. 路由懒加载

5. quicklink：在浏览器空闲时的时候去指定需要加载的数据

6. gzip压缩，减少文件体积，加快首屏页面打开速度

7. 外链CSS,JS文件

8. webpack entry：将单页应用改成多页应用

9. 骨架屏：骨架屏就是在进入项目的FP阶段，给它来一个类似轮廓的东西，当我们的页面加载完成之后就消失，这个也很好做的，很多ui库都有这个东西

10. loding：添加loadingcss效果

# 虚拟dom

一层对真实dom的抽象，以js对象作为基础的树，用对象的属性来描述节点，最终通过一系列操作将这棵树映射到真实环境上，**最少包含**tag(标签名)，属性(attrs)和子元素对象(children)

vue是通过createElement生成的vnode，![image-20211206213653284](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211206213653284.png)

**作用**：

dom元素非常庞大，而且页面很多的性能问题都是dom操作引起的，虚拟dom除了diff算法可以优化页面性能以外，其实抽离了原本的渲染过程，实现了跨平台的能力

# diff算法

**都会根据老的节点构建一个map，方便根据key快速查找**

一种对比新旧虚拟dom的一种方法， 找出需要更改的虚拟节点并对其进行更新，其他没有更新的则不用改变

使用虚拟dom算法的损耗计算：总损耗 = 虚拟dom增删改+(与diff算法效率有关)真实dom增删改+(较少的节点)排版和重绘

直接操作真实dom的损耗计算：总损耗 = 真实dom完全增删改+(可能较多的节点的)排版和重绘

**diff是深度优先算法，进行同层比较**

**流程：**

当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者Watcher，订阅者们会调用patch方法，给真实dom打补丁，更新相应的视图

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 上午11.49.38.png" style="zoom:67%;" />

## vue的diff算法

patch方法：

**对比当前同层的虚拟节点是否为同一种类型的标签**：

判断其是否是同一类型的标签的标准：

key值是否一样；标签名是否一样；是否都为注释节点；是否都定义了data；当标签是input时，type是否相同；

- 是：继续执行patchNode方法：

  - 找到对应的真实dom，称为el

  - 判断newNode和oldnode是否指向同一个对象，如果是，直接return

  - 如果他们都有文本节点并且不相等，那么直接将el的文本节点设置为newVnode的文本节点

  - 如果oldVnode有子节点而newVnode没有，则删除el的子节点

  - 如果oldVnode没有子节点而newVnode有，则将newVnode的子节点真实化之后添加到el

  - 如果两者都有子节点，则执行updateChildren函数比较子节点

    updateChildren方法：新的子节点集合和旧的子节点的集合各有首尾两个指针

    新旧节点首尾进行四次比较，如果四次都匹配不到，则将所有旧子节点的key做一个映射到旧节点下标的key=>index表，然后用新vnode的key去找出旧节点中可以复用的位置

- 否：没必要比对，直接整个节点替换成新虚拟节点

## vue2与vue3的对比

- vue2中会将没有发生更改的节点进行比较，比较消耗性能；在vue3中，创建虚拟dom树的时候，会根据dom中的内容会不会发生变化添加静态标记，在之后的过程中比较这些带有静态标记的节点。

​	摘自原文https://blog.csdn.net/qq_45613931/article/details/109470718

```js
export const enum PatchFlags {
  // 动态文本节点
  TEXT = 1,
  // 动态 class
  CLASS = 1 << 1, // 2
  // 动态 style
  STYLE = 1 << 2, // 4
  // 动态属性，但不包含类名和样式
  // 如果是组件，则可以包含类名和样式
  PROPS = 1 << 3, // 8
  // 具有动态 key 属性，当 key 改变时，需要进行完整的 diff 比较。
  FULL_PROPS = 1 << 4, // 16
  // 带有监听事件的节点
  HYDRATE_EVENTS = 1 << 5, // 32
  // 一个不会改变子节点顺序的 fragment
  STABLE_FRAGMENT = 1 << 6, // 64
  // 带有 key 属性的 fragment 或部分子字节有 key
  KEYED_FRAGMENT = 1 << 7, // 128
  // 子节点没有 key 的 fragment
  UNKEYED_FRAGMENT = 1 << 8, // 256
  // 一个节点只会进行非 props 比较
  NEED_PATCH = 1 << 9, // 512
  // 动态 slot
  DYNAMIC_SLOTS = 1 << 10, // 1024
  // 静态节点
  HOISTED = -1,
  // 指示在 diff 过程应该要退出优化模式
  BAIL = -2
} 
```

- vue3中存在最长递增子序列使得我们可以保证移动次数最少

## react的diff算法与vue的区别

- react在diff遍历的时候，只对需要修改的节点进行了记录，形成effect list，最后才会根据effect list进行真实的dom的修改，修改时先删除，然后更新和移动，最后插入
- vue在遍历的时候修改真实dom最后做删除操作
- react采用单指针从左到右进行遍历，vue采用双指针从两头向中间进行遍历

## 用index作为key的问题

vue中使用虚拟dom且根据diff算法进行新旧对比，从而更新真实dom，key是虚拟dom对象的唯一标识。

**如果旧虚拟dom中找到了与新虚拟dom相同的key：**

- 若虚拟dom中的内容没变，直接使用之前的真实dom
- 若虚拟dom中内容变了，则生成新的真实dom，随后替换掉页面中之前的真实dom

若对数据进行逆序添加，逆序删除等破i坏顺序操作：会产生没有必要的真实dom更新，页面效果没问题，但是效率低
如果结构中还包含输入类的dom：会产生错误dom更新=》界面有问题

如果不存在对数据的逆序添加或删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的

# vite

特点：

- 冷服务启动：没有打包过程，使用模块模式es6的import。
- 热更新：即时预览
- 按需加载当前页面所需文件，一个文件一个http请求，进一步减少启动时间
- 按需进行编译，不会刷新全部dom
- ssr支持

缺点：

- 兼容性不好，无论是 dev 还是 build 都会直接打出 ESM 版本的代码包，这就要求客户浏览器需要有一个比较新的版本
- 缺少show case
- 代价：对于vite开发团队来说，维护成本较高，对于开发者来说，随着项目复杂度的提高需要了解esbuild和rollup

注：

- vite主要应对的场景是开发模式，原理是拦截浏览器发出的ES imports请求并作出i相应处理(生产模式是用rollup打包)
- vite在开发模式下不需要打包，只需呀编译浏览器发出的http请求对应的文件即可，所以热更新速度很快

*打包的时候使用的rollup的这个打包器，以将小块代码编译成大块复杂的代码。Rollup 对代码模块使用新的标准化格式*

*ESbuild 是一个类似webpack构建工具。它的构建速度是 webpack 的几十倍。*

**vite的性能优化：**

- 预编译：npm这类不会变得模块，使用esbuild在预构建阶段先打包整理好，减少http请求数
- 按需编译：[用户代码](https://www.zhihu.com/search?q=用户代码&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A385926606})这一类频繁变动的模块，直到被使用时才会执行编译操作
- 客户端强缓存：请求过的模块会被以 http 头 `max-age=31536000,immutable` 设置为强缓存，如果模块发生变化则用附加的版本 query 使其失效
- vite尽量避免直接处理静态资源。例如引入图片 `import img from 'xxx.png'` 语句，执行后 `img` 变量只是一个[路径字符串](https://www.zhihu.com/search?q=路径字符串&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A385926606})。

![img](https://pic3.zhimg.com/80/v2-1a8f17cafea1d3c243f4cf2be4541536_720w.jpg)

## 热更新

webpack：**打包**。一旦发生某个依赖，就将这个依赖所处的module更新，并将新的module发送给浏览器重新执行。由于只打了一个bundle.js所以热更新也会重打这个bundle.js.如果依赖越来越多，就算只修改一个文件，理论上热更新的速度也会越来越慢。

vite：**只编译不打包。**最终产出的还是分离的分拣，只有编译耗时，当浏览器解析到import的手，会发起http请求，从而达到不打包也可以加载所需代码的目的。在热更新的时候，如果某个文件发生了改变，只需要更新其本身和用到该文件的文件即可，对于没有发生改变的无需重新编译，直接从缓存中获取结果，所以理论上热更新的速度不会变慢

### vite是通过websocket实现的热更新

- 创建一个websocket服务端
- 创建一个ws client文件，并在html中引入，加载ws client文件
- 服务的短监听文件变化，发送websocket消息，告诉客户端变化类型，变化文件等
- 客户端接收消息，根据消息内容决定重新刷新页面还是重新加载变化文件，并执行相关文件注入ws client时设置的热更新回调函数

# webpack

https://zhuanlan.zhihu.com/p/30669007

https://juejin.cn/post/6844904094281236487#heading-19

## webpack介绍

- 模块打包：可以将不同模块的文件打包整合在一起，并且保证他们之间的引用正确，执行有序
- 编译兼容：通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less, .vue, .jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。
- 能力扩展：通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。

## webpack配置项

entry——入口

output——出口

loader——加载器，加载需要处理的模块，对模块进行转换处理。两个属性：test。use

plugins——定义项目要用的插件

mode——模式development——开发环境，production——生产环境，none

module——决定如果和处理项目中的不同类型的模块

## webpack中loder和plugin的区别

loder运行在打包文件之前，plugins在整个编译周期都起作用
【Loader】：用于**对模块源码的转换，**loader描述了webpack如何处理非javascript模块，并且在build中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。

- raw-loader：加载文件原始内容
- file-loader：把文件输出到一个文件夹中，在代码中通过相对url去引用输出的文件
- url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)
- image-loader：加载并压缩图片文件
- json-loader：加载json文件
- babel-loader：将es6转成es5
- css-loader：加载css，支持模块化，压缩，文件导入特性
- style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
- eslint-loader：通过 ESLint 检查 JavaScript 代码
- vue-loader：加载vue.js单文件组件

【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。

- ignore-plugin：忽略部分文件
- clean-webpack-plugin：目录清理
- web-webpack-plugin：方便的为单页应用输出html
- webpack-parallel-uglify-plugin：多进程执行代码压缩，提升构建速度

## webpack模块打包运行原理

webpack打包流程：

**启动构建，读取合并配置文件以及shell中的参数，加载plugin，实例化compiler。从entry出发，针对每个module串行调用对应的loader去转换文件的内容，并找到该模块依赖的模块，递归的进行编译处理，将编译后的module组成chunk代码块，并将其转换成文件，输出到文件系统中**



**Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。**



整个过程中webpack会通过发布订阅模式，向外抛出一些hooks，而webpack的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。

其中文件的解析与构建是一个比较复杂的过程，在`webpack`源码中主要依赖于`compiler`和`compilation`两个核心对象实现。

`compiler`对象是一个全局单例，他负责把控整个`webpack`打包的构建流程。 `compilation`对象是每一次构建的上下文对象，它包含了当次构建所需要的所有信息，每次热更新和重新构建，`compiler`都会重新生成一个新的`compilation`对象，负责此次更新的构建过程。而每个模块间的依赖关系，则依赖于`AST`语法树。每个模块文件在通过`Loader`解析完成之后，会通过`acorn`库生成模块代码的`AST`语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。

## webpack中提高效率的插件

- webpack-dashboard：更友好的展示相关打包信息
- size-plugin：监控资源体积变化，尽早发现问题
- hotmodulereplacementplugin：模块热替换
- speed-measure-webpack-plugin：分析webpack打包过程中loader和plugin耗时
- webpack-merge：提取公共配置，减少重复配置代码

## 热更新

![33f3350112728e0d4d5a75202bb99db](C:\Users\田甜圈\AppData\Local\Temp\WeChat Files\33f3350112728e0d4d5a75202bb99db.jpg)

客户端从服务端拉取更新后的文件，就是代码块需要更新的那部分，实际上wds与浏览器之间维护了一个websocket，当本地资源发生变化时，wds会向浏览器推送更新，并且带上构建时的hash，让客户端与上一次资源进行比对，客户端对比出差异后会向wds发起ajax请求来获取更改内容（文件内容，hash），这样客户端就可以借助这些信息继续向wds发起jsonp请求来获取chunk的增量更新。后续由hotmoduleplugin来完成后续工作，比如拿到增量更新如何处理，那些状态应该保留，哪些又需要更新；hotmoduleplugin提供了相关api供开发者针对自身场景进行处理。

*wds：基于node.js的使用了express的http服务器*

# babel原理

- 解析：将代码转换为ast：
  - 词法分析：将代码分割为token流
  - 语法分析：分析token流并生成ast
- 转换：访问ast的节点进行变换操作生成新的ast
- 生成：以新的ast为基础生成代码

# react特点

声明式编码
组件化编码
reactnative编写原生应用
高效（优秀的diffing算法）：使用虚拟dom。domdiffing算法，页面最小化重绘

# jsx

作用：用来简化创建虚拟dom
语法规则：
1.定义虚拟dom时，不要写引号
2.标签混入js表达式时要用{}
3.内联样式，要用style={{key:value}}的形式去写。
4.样式的类名指定不要用class，要用className
5.只有一个根标签
6.标签必须闭合
\7. 标签首字母
 (1).若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。

 (2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。

# vue和react中key的作用

当状态中的数据发生变化时，react会根据新数据生成新的虚拟dom，随后react进行新虚拟dom与旧虚拟dom的diff比较，比较规则如下：
\1. 旧虚拟dom中找到了与新虚拟dom相同的key

- 若虚拟dom中内容没变，直接使用之前的真实dom
- 若虚拟dom中内容改变了，则生成新的虚拟dom，随后换掉页面中的真实dom

2.旧虚拟dom中未找到与新虚拟dom相同的key

- 根据数据创建新的真实dom，随后渲染到页面

# 函数组件与类组件的区别

函数组件是一个纯函数，接收一个props对象返回一个react元素，而类组件需要去继承react.Component并且创建render函数返回react元素

函数组件没有生命周期和状态state，而类组件有

# 计算机网络

<img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211130221432413.png" alt="image-20211130221432413" style="zoom:50%;" />

<img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211130221557778.png" alt="image-20211130221557778" style="zoom:50%;" />

![image-20211206154934687](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20211206154934687.png)

# restful

rest指的是一组架构约束条件和原则，如果一个架构符合rest的约束条件和原则，就称之为restful架构

- 用 URL 定位资源
- 用 HTTP 动词描述操作
- 命名规则
  - 全部小写，用 `_` 或 `-` 线连接。
  - URL 中只用名词指定资源，因为 REST 的核心是资源，而表示资源的词语天然就是名词。
  - 资源用复数表示。
- 版本
  - 一种方法是在 URL 中添加版本号
  - 将版本号加在 HTTP 请求头信息的 Accept 字段中，
- 状态码

## http协议幂等性

http幂等性：指一次和多次请求某一个资源应该具有同样的副作用

请求已经被服务端正确处理，但服务端的返回结果由于网络原因丢失了，客户端无法知晓，用户重复发起请求，服务端进行第二次操作

为了解决以上问题，两种解决方案

- 一是采用分布式事务，通过引入支持分布式事务的中间件来保证功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。
- 更轻量级的解决方案是幂等设计。和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。![image-20210811093131429](C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210811093131429.png)

##  计算机网络体系结构

<img src="C:\Users\田甜圈\AppData\Roaming\Typora\typora-user-images\image-20210817183222250.png" alt="image-20210817183222250" style="zoom:80%;" />

1. osi：概念清楚&理念完整，复杂不实用

2. tcp/ip：包含一系列互联网基础的网络协议，被广泛应用于局域网和广域网

3. 五层体系结构：融合前两种，目的是为了学习&讲解计算机原理

4. 各个层次之间的交互：

   浏览器输入链接时，客户端进入应用层

   - 应用层：
     - 处理报文：解析请求参数，请求hash值，请求域名，请求头
     - dns解析
   - 传输层：
     - 建立端口到端口的关系
     - tcp/udp协议
     - 将报文切成n个报文段
   - 网络层：
     - arp协议，IP协议
     - ip协议分为IPV4,IPV6
     - ARP协议：简单来说，就是通过广播的形式，将'数据包'发送出去。

   - 数据链路层：
     - 传输层生成的报文段，转移给物理层
     - 以太网协议：数据包称为 帧，帧由 标头 和 数据 两部分组成
     - 每一台设备的网卡都会有一个mac地址，用来唯一标识设备的
   - 物理层：
     - 将数据包转换为电信号
     - 物理手段，网线，光纤，无线 等。跟硬件有关。

##  http常用状态码及使用场景

状态码：当客户端向服务端发送请求时，描述返回的请求结果

1xx：接收的请求正在处理

2xx：请求正常处理完毕

3xx：表示重定向状态，需要进行附加操作完成请求

4xx：客户端错误状态码，服务器无法处理请求

5xx：服务器错误状态码，服务器处理请求出错

**常用状态码：**

- 100 CONTINUE：继续，客户端应继续其请求
- 101：切换请求协议，从http切换至websocket
- 200 OK：请求成功，有响应体
- 201 created：已成功请求并创建了新的资源
- 204  No Content：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分
- 206 Partical Content :表示客户端进行了范围请求，而服务器成功的执行了这部分的get请求，响应报文中包含Content-Range范围内容
- 301Moved Permanently：**永久性重定向**。该状态码表示请求的资源已经分配了新的url 
- 302 Found：**临时性重定向**：该状态码表示请求的资源已经分配了新的url，希望本次能够以新的uri进行访问
- 303 See Other：该状态码表示由于请求对应得资源存在着另一个uri，应该使用get方法定向获取请求资源
- 304 Not Modified：该状态码表示客户端发送附带条件得请求时，服务器端允许请求去访问资源，但因请求未满足条件的情况后，直接返回304。304状态码返回时，不包含任何相应得主体部分
- 307Temporary Redirect ：临时重定向。,遵守浏览器标准， 不会将post请求改为get请求
- 400 BadRequest：请求报文中存在语法错误。当错误发生时，需修改请求得内容后再次发送请求，浏览器会像200OK一样对待该状态码
- 401 Unauthorized：表示发送的请求需要有通过http认证得认证信息。响应中必须包含一个适用于被请求资源得WWW-Authenticate首部用于质询用户信息
- 403Forbidden：表示对请求资源得访问被服务器拒绝了。如果想对拒绝原因给出详细理由在实体的主体部分对原因进行描述
- 404 Not Found：表示服务器无法再找到请求得资源，也可以在服务器端拒绝请求且不想说明理由时使用
- 500Internal Server Error：表示服务器在执行请求时发生了错误，也可能时web应用存在得bug或某些临时得故障
- 503 Service Unavailable：表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

##  http常用得请求方式，区别以及用途

http1.0定义了get post head

http1.1新增了五种 options，put delete trace connect

- get：通用于获取数据，请求访问已被uri识别的资源。
- post：提交数据。用来传输实体主体
- put：传输文件，由于http1.1的put方法不带验证机制，任何人都可以上传文件，所以一般网站不使用
- delete：删除文件，按请求uri删除指定资源。http1.1不带验证机制，所以一般也不使用，配合web应用程序的验证机制，或遵守rest标准时有可能开放使用
- head：获得报文首部，不返回报文主体部分，用于确认uri的有效性和资源更新的日期时间等
- options：询问支持的方法。用来查询针对请求uri值定的资源支持的方法
- trace：追踪路径。让web服务器端将之前的请求通信返回给客户端的方法
- connect：要求用隧道协议链接代理，主要用ssl安全套接层和tls传输层安全协议将同i性能内容经网络隧道传输

**get，post的区别：**

1. 传送方式：get通过地址栏传输，post通过报文传输，所以post更加安全
2. 传输长度：get参数有长度限制(url长度)，post无长度限制
3. Get只能支持ascII字符，post支持标准字符集，可以传输中文
4. Get在回退时是无害的，post会再次提交申请
5. Get请求的参数会完整的保存在浏览器记录中，post不会
6. Get产生一个tcp包，post产生两个
7. Get会把请求和请求数据一起发过去，post会先和服务器打个招呼，服务器响应100countinue之后才会发送数据包，而后服务器响应200。数据查询使用get，牵扯到安全性操作使用post

**put和post的区别**：

put方法是幂等的，连续调用一次或者多次的效果相同，而post是非幂等的

**put和patch的区别：**

PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新。

## 请求报文&响应报文

请求报文是由请求方法，请求uri，协议版本，可选的请求首部字段和内容实体构成的

响应报文：协议版本，状态码，用以解释状态码的原因短语，可选的响应首部字段以及实体主体

## 持久连接节省通信量：

- 持久连接：只要任意一段没有提出断开连接，则保持tcp连接状态
- 管线化：同时并行发送多个请求，不需要一个接一个的等待响应——请求得到响应后才能发送下一个请求

## http，https，http1，http2，http3

**http**（超文本传输协议）用于浏览器与服务器间传递信息，http协议无状态（不保存状态）且使用明文传输，不对信息进行加密。进而发展出了**https**（安全超文本传输协议），其在http的基础上加入了SSL安全套接层/TLS通信加密协议。   //http使用80端口，https使用443端口

客户端使用https与服务器通信的步骤（非对称加密）

（1） 客户端使用https的url访问服务器并要求建立SSL连接

（2） Web服务器收到客户端请求后将网站的证书信息（包含公钥）传给客户端

（3） 客户端浏览器与服务器协商加密等级

（4） 客户端浏览器根据加密等级建立会话密匙，而后用公钥加密密匙传输给服务器

（5） 服务器使用自身私钥解密出会话密钥

（6） 客户端与服务器开始通信

https作用：

- 建立安全信息通道，保证数据的安全性
- 确认网站的真实性

https缺点：

- 由于存在复杂的验证阶段，https协议的握手时间会比较费时
- https加密范围有限
- https链接缓存不如http高效，会增加数据开销

对称加密与非对称加密最主要的区别就是对称加密使用相同的密匙进行解密，而非对称加密像是发送了一个锁，接收方将自己的钥匙挂在锁上传回来，加密方再使用自己的钥匙开锁获得对方的密匙

## websocket

h5提供的一种浏览器与服务器进行**全双工通信**的网络技术，属于应用层协议。

1. 单向通信/单工通信：只能由一个方向的通信而没有反方向的交互
2. 双向交替通信/半双工通信：通信双发都可以发送信息，但不能双方同时发送
3. 双向同时通信/**全双工通信**：**通信双发可以同时发送和接收信息**

特点：

（1）建立在 TCP 协议之上，服务器端的实现比较容易。


（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

一些api：

- webSocket.onopen：连接成功后的回调函数
- webSocket.onclose：用于指定连接关闭后的回调函数
- webSocket.onmessage:用于指定收到服务器数据后的回调函数
- webSocket.send():用于想服务器发送数据

## tcp与udp区别

- tcp是面向连接的，收发数据前必须要建立链接；udp是无连接的
- tcp是可靠传输，数据无差错交付使用流量控制和拥塞控制；udp是不可靠传输，不使用流量控制和拥塞控制
- tcp只能是一对一通信，udp支持一对一，一对多，多对多和多对一
- tcp的传输方式是面向字节流的，没有边界，udp是面向报文的，一个一个包的发送，有边界，可能会丢包或者乱序
- tcp首部最小20字节，最大60字节；udp首部开销小，仅8字节
- tcp适用于要求可靠传输的应用，例如文件传输；udp适用于实时应用

# 操作系统

## 1.进程线程协程

- 进程是操作系统资源分配的基本单位，线程是任务执行和调度的基本单位。
- 进程有独立的地址空间，拥有pcb——进程控制块，进程存在的唯一标识；线程拥有自己的PCB，但是没有独立的地址空间
- 同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。
- 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮
- 线程是进程的基本执行单元，一个进程的所有任务都在线程中执行，进程至少要有一条线程

协程：多个线程互相协作，完成异步任务

## 2.进程的状态

1. 就绪状态：进程已处于准备好运行的状态，即进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。
2. 执行状态：进程已获得CPU，其程序正在执行的状态
3. 阻塞状态：正在执行的进程由于发生某事件暂时无法继续执行时的状态。通常将处于阻塞状态的进程也排成一个队列——阻塞队列![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\0077ac50-b4a9-4c30-81ea-f4de11fbcfaf.png?t=1627294373826)
4. 创建状态：**进程正在被创建，尚未转到就绪状态。**首先由进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后把该进程转入就绪状态并插入到就绪队列中。但如果进程所需资源尚不能得到满足，创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为创建状态。引入创建状态是为了保证进程的调度必须再创建工作完成后进行，以确保对进程控制块操作的完整性。创建状态的引入也增加了管理的灵活性,OS可以根据系统性能或主存容量的限制推迟新进程的提交。对于处于创建状态的进程，当期获得了所需资源以及对其PCB的初始化工作完成后，便可由创建状态转为就绪状态。
5. 终止状态：**进程正在从系统中消失，分为正常结束和异常退出。**首先是等待操作系统进行善后处理，最后将PCB清零，并将PCB空间返还系统

## 3.死锁

1. 死锁：一组竞争系统资源或相互通信的进程相互的永久阻塞。若无外力作用，这组进程将永远不能执行
2. 造成死锁的原因：
   1. 资源数<要求该种资源的进程数——资源数量不足
   2. 进程推行顺序不当
3. 产生死锁的必要条件：
   1. 互斥条件。临界资源——互斥访问方法，不可以被抢占的资源
   2. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程所占有，此时请求进程被阻塞，但对自己已获得的资源保持不放
   3. 不可抢占条件：进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放
   4. 循环等待条件。发生死锁时会存在一个进程——资源的循环链
4. 死锁的避免：动态决定是否分配资源给进程，防止系统进入不安全状态。安全状态是指系统至少存在一个安全序列<P1,P2,...,PN>,按照这个序列为进程分配资源，直到满足最大需求，每个进程都可顺序完成。若系统不存在这样一个安全序列，则系统处于不安全状态。

## 4.中断：多道程序实现的基础，也是设备管理的基础。中断是IO系统最低一层，是整个IO系统的基础。

1. 1. 外/硬中断：CPU对IO设备法类似的中断信号的一种响应。中断是由外部设备引起的。
   2. 内/软中断/陷入：由CPU内部事件引起的中断。如溢出，非法指令，地址越界等。
   3. 软硬中断处理过程：CPU暂停正在执行的程序，保留CPU环境后，自动的转去执行该IO设备的中断处理程序。执行完后，再回到断点，继续执行原来的程序。

## 5.浏览器进程

多进程造成的问题：更高的资源占用；更复杂的体系结构：浏览器间的耦合性高，扩展性差

1. **browser进程**：浏览器的主进程，该进程只有一个；负责浏览器界面显示，与用户**交互**；负责**各个页面的管理**，创建和销毁其他进程；将渲染进程得到的内存中的Bitmap(位图)，绘制到用户界面上；网络资源的管理，下载等
2. **第三方插件进程**：每种类型的插件对应一个进程，当使用该插件时才创建
3. **GPU进程**：该进程只有一个，用于3D绘制等等
4. **渲染进程**：即通常所说的浏览器内核(**render进程，内部是多进程**)；每个tab界面都有一个渲染进程，互不影响；主要用于页面渲染，脚本执行，事件处理等

**render进程，内部是多进程**

- GUI渲染进程

  ：负责渲染浏览器界面，解析HTML，CSS。构建DOM树和renderObject树，布局和绘制等。当页面需要重绘和重排时GUI线程执行，绘制页面。GUI渲染线程和JS引擎是互斥的

  - 解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree
  - 解析css，生成CSSOM(CSS规则树)
  - 把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)

- **js引擎线程**——js内核，负责处理js脚本程序，浏览器同时只能有一个js引擎线程在运行js程序

- **事件触发线程**：控制事件循环，管理事件队列。

- **定时器触发线程**

- **异步http请求线程**：就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行

# 前端安全

https://juejin.cn/post/6929281260045434894

https://mp.weixin.qq.com/s/xRCLKE8KAS_BdrbfryFaCQ

## xss——跨站脚本攻击

攻击者通过注入非法的html标签或者js代码，使当前用户浏览改网页时，控制用户浏览器

代码注入攻击，攻击者在目标网站上诸如恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取cookie，session tokens，或者其他敏感的信息，对用户进行钓鱼欺诈

**xss的本质**：恶意代码未经过过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意代码脚本被执行，有助于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击这定义的请求

- domxss：触发xss靠的是浏览器端的dom解析。实际上就是前端js代码不够严谨，将不可信内容插入页面。取出和执行恶意代码由浏览器端完成，属于前端自身的安全漏洞

  - 攻击者构造出特殊数据，其中包含恶意代码
  - 用户浏览器执行了恶意代码
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

  防范：

  - 对于url链接直接使用encodeURIComponent来转义

  - 非`url`，我们可以这样进行编码：

    ```
    function encodeHtml(str) {
        return str.replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
    }
    ```

- 反射性xss：**url参数直接注入**非持久性，发出请求时，xss代码出现在url中，最后输入提交到服务器，服务器解析后在相应内容中出现xss代码，最后浏览器解析执行

  - 攻击者构造特殊的url，其中包含恶意代码
  - 用户打开带有恶意代码的 `URL` 时，网站服务端将恶意代码从 `URL` 中取出，拼接在 HTML 中返回给浏览器。
  - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

- 存储型xss：**存储到db后读取时注入**，持久性xss，允许用户存储数据的web程序都有可能存在，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。

  - 攻击者将恶意代码提交到目标网站的数据库中。
  - 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
  - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。


xss造成影响：

- 利用虚假输入表单骗取用户个人信息
- 利用脚本窃取用户的cookie值，被害者在不知情的情况下，帮助攻击者发送而已请求
- 显示伪造的文章或图片

防御：

- httponly：在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。
- 过滤：输入检查，HtmlEncode——标签转换。jsencode
- 对字符串进行转移编码

## csrf——跨站请求伪造

冒充用户发起请求（用户不知情），完成违背用户意愿的事情![img](https://static.jkchao.cn/front5.png?imageMogr2/auto-orient/thumbnail/630x/blur/1x0/quality/75|imageslim)

**影响：**

- 利用已经通过验证的用户权限更新设定信息等
- 利用以通过认证的用户权限购买商品
- 利用已通过的用户权限在留言板上发表评论

**与xss区别**

- csrf是由xss实现的，CSRF 时常也被称为 XSRF 
- xss是代码注入问题，csrf是http问题。XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面。 

**防御：**

- 验证码：强制用户与应用进行交互，完成最终请求
- 尽量使用post，限制get使用
- referer check：请求来源设置
- token：服务端生成的一串字符串令牌，第一次成功登录后服务器生成一个token令牌并返回给客户端，后续客户端在只要带上这个token来请求数据即可，无需带上用户和密码。这项技术可以减少服务器压力，减少查询数据库的次数，使服务器更加健壮  
  - 后端随机生成一个token，将token保存到session状态中；同时后端将token交给前端页面
  - 前端页面提交请求时，将token加入到请求数据或头信息中，一起穿给后端
  - 后端验证前端传来的token与session值是否一致，一致则合法，否则是非法请求。 若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。

## 点击劫持
利用透明按钮或链接做成陷阱，覆盖在web页面上，然后诱使用户在不知情的情况下，点击那个连接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing) 

两种方式：

- 攻击者使用一个透明iframe。覆盖在一个网页上，诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的 iframe 页面； 
- 攻击者使用一张图片覆盖在网页上，遮挡网页原有的位置含义

**防御**：

- X-FRAME-OPTIONS：

  X-FRAME-OPTIONS响应头**是用来给浏览器指示允许一个页面是否在, <frame>,<iframe> 或者 <object> 中展现的标记**。网站可以使用此功能，来确保自己网站内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击,有三个值
  
  - DENY：表示页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。
  - SAMEORIGIN：表示该页面可以在相同域名页面的 frame 中展示。 
  - ALLOW-FROM url：表示该页面可以在指定来源的 frame 中展示。
  
- ###### js判断顶层窗口

## 前端常用加密算法

https://juejin.cn/post/7011306453373812744

- MD5：加密后的位数有两种，16位与32位，默认使用32位，（16 位实际上是从 32 位字符串中取中间的第 9 位到第 24 位的部分）为提高安全性。根据业务需求，可以对md5 添加偏移量。如对原有字符拼接指定位数的字符串。
- base64加密
- res加密
- rsa非对称加密

## sql注入

让服务器执行攻击者期望的SQL语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。

思路：
将SQL语句放置于Form表单或请求参数之中提交到后端服务器，后端服务器如果未做输入安全校验，直接将变量取出进行数据库查询，则极易中招。

## ddos攻击

分布式拒绝服务攻击
攻击者不断地提出服务请求，让合法用户的请求无法及时处理，就是dos攻击
攻击者使用多台计算机或者计算机集群进行dos攻击，就是ddos攻击

## dns劫持

DNS域名解析系统
DNS提供服务用来将域名转换成IP地址

## json劫持

对数据进行窃取，将本该返回给用户的json输一局进行拦截，转二将数据发送给恶意攻击者

## 暴力破解

## http报头追踪漏洞

HTTP/1.1（RFC2616）规范定义了 HTTP TRACE 方法，主要是用于客户端通过向 Web 服务器提交 TRACE 请求来进行测试或获得诊断信息。

当 Web 服务器启用 TRACE 时，提交的请求头会在服务器响应的内容（Body）中完整的返回，其中 HTTP 头很可能包括 Session Token、Cookies 或其它认证信息。攻击者可以利用此漏洞来欺骗合法用户并得到他们的私人信息。

解决方案：
禁用HTTP TRACE方法

## 信息泄露

由于 Web 服务器或应用程序没有正确处理一些特殊请求，泄露 Web 服务器的一些敏感信息，如用户名、密码、源代码、服务器信息、配置信息等。

所以一般需注意：

应用程序报错时，不对外产生调试信息 过滤用户提交的数据与特殊字符 保证源代码、服务器配置的安全

## 目录遍历漏洞

攻击者向 Web 服务器发送请求，通过在 URL 中或在有特殊意义的目录中附加 ../、或者附加 ../ 的一些变形（如 .. 或 ..// 甚至其编码），导致攻击者能够访问未授权的目录，以及在 Web 服务器的根目录以外执行命令。

## 命令执行漏洞

命令执行漏洞是通过 URL 发起请求，在 Web 服务器端执行未授权的命令，获取系统信息、篡改系统配置、控制整个系统、使系统瘫痪等。

## 文件上传漏洞

# git

## 集中式&分布式

**集中式**版本控制系统是将版本库集中的存放于中央服务器，每一次进行项目开发都需要在中央服务器获取最新版本，才可以继续编写代码，待代码编辑完成后，推送到中央服务器上，但获取代码及推送代码都需要联网。过于依赖服务器。

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\cd67a3ac-9bc1-4a62-aed2-e41ddb8e0bcb.png?t=1637066975400)

**分布式**版本控制系统没有中央服务器，每个人的电脑中都有完整的版本库，提高了代码存储的安全性。

![image.png](file://C:\Users\田甜圈\Documents\FocusNote\assets\5b83debf-66c3-4c88-86f3-6fa655767219.png?t=1637066975403)

## 工作区&暂存区

git管理的是修改。eg:当add后工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改型没有放入暂存区，所以git commit只是把暂存区的修改提交了，第二次的修改没有提交。

工作区指的是工作的区域，可以理解为本机；

暂存区指的是暂时保存文件的区域，.git文件中的index文件就是git的暂存区.

![git-repo](file://C:\Users\田甜圈\Documents\FocusNote\assets\e2d40c46-5049-4f8f-a9c5-fa8be32d0aba.png?t=1637066975408)

## 基本使用流程

1. 在当前想要管理的文件夹中，右键 git bash here
2. 初始化版本库，出现.git文件夹

```
$ git init
```

1. 添加文件至版本库，可以使用tab键补全文件名

```
$ git add tyx.txt     //加入某个文件
$ git add .           //加入当前仓库全部文件
```

1. 提交文件至版本库

```
$ git commit -m 'add first' //-m为添加备注的意思,''引号当中添加想要对本次commit的描述
```

1. github中创建仓库，new一个repositories![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\8250213b-bd20-442f-bc94-80e3700153ec.png?t=1637066975417)
2. 填入repository name后根据自己选择其他配置，description为项目的描述，public为任何人对项目可见，public只对授权的人可见；如果现有存储库则跳过下方步骤，配置结束点击下方绿色按钮

![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\3b9e6b26-385d-495b-97a8-22be7730e57c.png?t=1637066975420)创建新仓库则按照第一部分代码块进行操作，如果是已有存储库则按照第二个代码块操作![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\6e6e5c1c-5a4b-4685-8a51-0d2f643880a6.png?t=1637066975420)

## 创建仓库

### master——出现在仓库名后面，代表主分支

### 配置本地仓库

1. global为全局设置，local为本地设置

```
$ git config --global/local user.name='tyx'
$ git config --global/local user.email='tyx5637@163.com'
```

1. 可以通过**git config --global --list**查看配置列表 ![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\ed4d7808-fbff-4dcd-b689-adbfca64e57f.png?t=1637066975430)
2. 版本库可以跟踪的文件类型：只能跟踪到文本文件的改动，一些二进制文件是没有办法被版本控制系统跟踪到

## 查看版本库状态

```
$ git status
```

四种状态：untracked——未跟踪

​				staged——暂存

​				modified——已修改

​				unmodified——未修改![img](file://C:\Users\田甜圈\Documents\FocusNote\assets\edb46749-52b0-4633-8cf5-8bd97c75f0d9.png?t=1637066975434)一个新添加进工作区的文件的状态是untracked；

执行add命令后状态为staged；

提交该文件(commit)后状态为unmodified；

当修改了某个已提交的文件后，状态为modified；

当添加了某个修改的文件后，该文件的状态为staged；

在提交的文件中删除了某个文件后，文件状态为untracked；

## 查看提交日志

```
$ git log --pretty=oneline // --pretty=online起美化作用
```

## 版本回退

```
$ git reset --hard commit_id //回退到上一个版本
```

git reflog——用来记录每一次命令

## 管理修改

```
$ git diff HEAD -- readme.txt // 查看工作区和版本库里最新版本的区别
```

## 丢弃工作区的修改——就是回到最近一次add或commit时的状态

```
$ git checkout -- <file>
```

## 删除文件

```
$ git rm <file>
```

**从来没有被添加到版本库就删除的文件是无法恢复的**

## Git远程仓库

### 链接远程仓库

- 创建SSH Key

在用户主目录下生成.ssh目录下的id_rsa或id_rsa.pub

```
ssh-keygen -t rsa -C "youremail@example.com"  //之后一路回车就可以
```

生成完成后id_rsa为私钥，不可泄漏，id_rsa.pub为公钥

- 登录GitHub、打开Account Setting、SSH Key，点击Add SSH Key，在文本框中粘贴id_rsa.pub文件内容

![github-addkey-1](file://C:\Users\田甜圈\Documents\FocusNote\assets\a4a93645-5f58-4b7e-a9fd-7ea3ab0d725e.png?t=1637066975461)

可将多设备的SSH Key添加至仓库，这样就可以在多设备上向一个仓库提交代码

### 添加远程仓库

登录后点击Create a new repo创建一个新的仓库

![github-create-repo-1](file://C:\Users\田甜圈\Documents\FocusNote\assets\7de67701-3392-4d30-8da7-8a136f3635a3.png?t=1637066975464)

之后根据空仓库给出的步骤在本地进行操作

```
git remote add origin (SSH)  //链接远程库
git push -u origin master//将本地push至远程，-u代表git会将本地master分支和远程master分支关联，简化push或pull命令
```

之后就可以通过命令进行提交

```
git push origin master   //将本地版本库master内容推送至名为origin的远程仓库master分支上
```

### 删除远程仓库

可在本地使用命令查看远程库并将远程库“删除”

```
git remote -v    //查看远程库信息
git remote rm <name>  //解除与目标远程库的绑定关系
```

### 克隆远程仓库

```
git clone <ssh/https>
```

## 分支管理

### 创建并切换分支

```
$ git checkout -b dev 
// 或者
$ git switch -c dev
// 相当于
$ git branch dev   // 创建分支
$ git checkout/switch dev // 切换分支
```

### 查看分支

```
$ git branch
```

### 合并分支

```
$ git merge dev //将dev分支的工作成果合并到当前分支上
```

### 删除分支

```
$ git branch -d dev
```

### 查看分支合并情况

```
$ git log --graph --pretty=oneline 
```

### 分支管理策略

合并分支时加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来做过合并，fastforward合并看不出来曾经做过合并

### bug分支

```
$ git stash // 存储当前工作区
```

解决bug之后两种方法回复之前工作过场景

1. 

```
$ git stash apply // 恢复
$ git stash drop //删除stash内容
```

1. 

```
$ git stash pop // 恢复的同时删掉stash内容
```

#### 复制特定提交到当前分支

```
$ git cherry-pick <commit>
```

### 强行删除一个没有合并过的分支

```
$ git branch -D <name>
```

## 多人协作

### 查看远程库信息

```
git remote //加上-v可以查看更详细的内容
```

### 推送分支

```
git push origin (分支名称)   //推送origin仓库的指定分支
```

### 当遇到提交冲突时

```
git pull  //在冲突分支中将最新版本拉取到本地
//在本地将冲突解决完成后重新提交
```

### 当本地pull也失效时需要通过命令指定本地分支与远程分支的链接

```
git branch --set-upstream-to=origin/dev dev   //示例，其将dev与远程origin/dev进行链接
```

因此，多人协作的工作模式通常是这样：

1. 1. 首先，可以试图用`git push origin <branch-name>`推送自己的修改；
   2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；
   3. 如果合并有冲突，则解决冲突，并在本地提交；
   4. 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！
   5. 如果 `git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to <branch-name> origin/<branch-name>`。

### 使用命令将本地未push的分支提交历史整理成直线

```
git rebase
```



# 代码规范

- 变量名函数名语义化

- 使用const定义常量

- 对功能类似的变量名采用统一的命名风格-

- 使用易于检索的名称

- 避免无意义的条件判断

- 函数参数不应超过两个

- 函数功能单一

- 移除重复代码

- 使用默认参数精简代码

- 使用Object.assign设置默认对象

- 采用函数式编程：使用函数来抽象作用在数据之上的控制流和操作，从而在系统中消除副作用并减少对状态的改变
  可扩展性——我是否需要不断地重构代码来支持额外的功能？
  易模块化——如果我更改了一个文件，另一个文件是否会受到影响？
  可重用性——是否有很多重复的代码？
  可测性——给这些函数添加单元测试是否让我纠结？
  易推理性——我写的代码是否非结构化严重并难以推理？

  函数式编程主要应思考怎样组织才能使数据流更加明显
  应尽量保证有输入值并且有返回值
  尽量使用显式模式而不是隐式模式
  将函数参数逐个减少的过程称为偏应用

# 方法

## encodeURIComponent比encodeURI有什么区别?

都是将字符串作为 URI 组件进行编码，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码

encodeuri使用宇url跳转时，encodeURIComponent适用于url作为参数传递时

## math

- math.floor——向下取整
- math.ceil——向上取整
- math.random——取0~1之间的随机数
- math.pow()——指数运算
- math.max()——返回给定数字中的最大值：

## window.requestAnimationFrame

你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

## setTimeout和setInterval

settimeout()——指定毫秒数调用函数

setinterval()——每隔一段时间就执行一次

## mutationobserver

[`MutationObserver`](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)接口提供了监视对DOM树所做更改的能力。

## object.observe()

Object.observe() 用来实时监测js中对象的变化，变化时调用一个方法
